	.zxbasic
	org 24000
	; Defines HEAP SIZE
ZXBASIC_HEAP_SIZE EQU 1024
__START_PROGRAM:
	di
	push ix
	push iy
	exx
	push hl
	exx
	ld hl, 0
	add hl, sp
	ld (__CALL_BACK__), hl
	ei
	call __MEM_INIT
	call __PRINT_INIT
	ld hl, 0
	ld b, h
	ld c, l
__END_PROGRAM:
	di
	ld hl, (__CALL_BACK__)
	ld sp, hl
	exx
	pop hl
	exx
	pop iy
	pop ix
	ei
	ret
__CALL_BACK__:
	DEFW 0
_Dibujar:
	push ix
	ld ix, 0
	add ix, sp
	ld hl, -26
	add hl, sp
	ld sp, hl
	ld (hl), 0
	ld bc, 25
	ld d, h
	ld e, l
	inc de
	ldir
	push ix
	pop hl
	ld bc, -7
	add hl, bc
	ex de, hl
	ld hl, __LABEL33
	ld bc, 2
	ldir
	ld l, (ix+4)
	ld h, (ix+5)
	ld (ix-5), l
	ld (ix-4), h
__LABEL0:
	ld a, (ix-3)
	sub 255
	jp z, __LABEL1
	ld l, (ix-5)
	ld h, (ix-4)
	ld a, (hl)
	ld (ix-1), a
	push af
	ld a, 191
	pop hl
	cp h
	jp nc, __LABEL3
	ld a, (ix-1)
	ld (ix-3), a
	ld l, (ix-5)
	ld h, (ix-4)
	inc hl
	ld (ix-5), l
	ld (ix-4), h
__LABEL3:
	ld a, (ix-3)
	sub 200
	sub 1
	sbc a, a
	push af
	ld a, (ix-3)
	sub 250
	sub 1
	sbc a, a
	pop de
	or d
	jp z, __LABEL4
	ld l, (ix-5)
	ld h, (ix-4)
	ld a, (hl)
	ld l, a
	ld h, 0
	ld (ix-15), l
	ld (ix-14), h
	ld l, (ix-5)
	ld h, (ix-4)
	inc hl
	ld a, (hl)
	ld l, a
	ld h, 0
	ld (ix-13), l
	ld (ix-12), h
	ld l, (ix-5)
	ld h, (ix-4)
	inc hl
	inc hl
	ld a, (hl)
	ld l, a
	ld h, 0
	ld (ix-19), l
	ld (ix-18), h
	ld l, (ix-5)
	ld h, (ix-4)
	inc hl
	inc hl
	inc hl
	ld a, (hl)
	ld l, a
	ld h, 0
	ld (ix-17), l
	ld (ix-16), h
	ld l, (ix-5)
	ld h, (ix-4)
	ld de, 4
	add hl, de
	ld (ix-5), l
	ld (ix-4), h
	ld l, (ix-13)
	ld h, (ix-12)
	ld a, l
	push af
	ld l, (ix-15)
	ld h, (ix-14)
	ld a, l
	call PLOT
	ld l, (ix-17)
	ld h, (ix-16)
	push hl
	ld l, (ix-13)
	ld h, (ix-12)
	ex de, hl
	pop hl
	or a
	sbc hl, de
	push hl
	ld l, (ix-19)
	ld h, (ix-18)
	push hl
	ld l, (ix-15)
	ld h, (ix-14)
	ex de, hl
	pop hl
	or a
	sbc hl, de
	call DRAW
	ld a, (ix-3)
	sub 250
	jp nz, __LABEL7
__LABEL8:
	ld l, (ix-19)
	ld h, (ix-18)
	push hl
	ld de, 200
	pop hl
	call __LTI16
	or a
	jp z, __LABEL9
	ld l, (ix-17)
	ld h, (ix-16)
	ld (ix-13), l
	ld (ix-12), h
	ld l, (ix-19)
	ld h, (ix-18)
	ld (ix-15), l
	ld (ix-14), h
	ld l, (ix-5)
	ld h, (ix-4)
	ld a, (hl)
	ld l, a
	ld h, 0
	ld (ix-19), l
	ld (ix-18), h
	ld l, (ix-19)
	ld h, (ix-18)
	push hl
	ld de, 200
	pop hl
	call __LTI16
	or a
	jp z, __LABEL11
	ld l, (ix-5)
	ld h, (ix-4)
	inc hl
	ld a, (hl)
	ld l, a
	ld h, 0
	ld (ix-17), l
	ld (ix-16), h
	ld l, (ix-5)
	ld h, (ix-4)
	inc hl
	inc hl
	ld (ix-5), l
	ld (ix-4), h
	ld l, (ix-17)
	ld h, (ix-16)
	push hl
	ld l, (ix-13)
	ld h, (ix-12)
	ex de, hl
	pop hl
	or a
	sbc hl, de
	push hl
	ld l, (ix-19)
	ld h, (ix-18)
	push hl
	ld l, (ix-15)
	ld h, (ix-14)
	ex de, hl
	pop hl
	or a
	sbc hl, de
	call DRAW
__LABEL11:
	jp __LABEL8
__LABEL9:
__LABEL7:
	jp __LABEL5
__LABEL4:
	ld a, (ix-3)
	sub 201
	jp nz, __LABEL12
	ld l, (ix-5)
	ld h, (ix-4)
	ld a, (hl)
	ld l, a
	ld h, 0
	ld (ix-15), l
	ld (ix-14), h
	ld l, (ix-5)
	ld h, (ix-4)
	inc hl
	ld a, (hl)
	ld l, a
	ld h, 0
	ld (ix-13), l
	ld (ix-12), h
	ld l, (ix-5)
	ld h, (ix-4)
	inc hl
	inc hl
	ld a, (hl)
	ld l, a
	ld h, 0
	ld (ix-19), l
	ld (ix-18), h
	ld l, (ix-5)
	ld h, (ix-4)
	inc hl
	inc hl
	inc hl
	ld a, (hl)
	ld l, a
	ld h, 0
	ld (ix-17), l
	ld (ix-16), h
	ld l, (ix-5)
	ld h, (ix-4)
	ld de, 4
	add hl, de
	ld (ix-5), l
	ld (ix-4), h
	ld l, (ix-13)
	ld h, (ix-12)
	ld a, l
	push af
	ld l, (ix-15)
	ld h, (ix-14)
	ld a, l
	call PLOT
	ld l, (ix-17)
	ld h, (ix-16)
	push hl
	ld l, (ix-13)
	ld h, (ix-12)
	ex de, hl
	pop hl
	or a
	sbc hl, de
	push hl
	ld hl, 0
	call DRAW
	ld hl, 0
	push hl
	ld l, (ix-19)
	ld h, (ix-18)
	push hl
	ld l, (ix-15)
	ld h, (ix-14)
	ex de, hl
	pop hl
	or a
	sbc hl, de
	call DRAW
	ld l, (ix-13)
	ld h, (ix-12)
	push hl
	ld l, (ix-17)
	ld h, (ix-16)
	ex de, hl
	pop hl
	or a
	sbc hl, de
	push hl
	ld hl, 0
	call DRAW
	ld hl, 0
	push hl
	ld l, (ix-15)
	ld h, (ix-14)
	push hl
	ld l, (ix-19)
	ld h, (ix-18)
	ex de, hl
	pop hl
	or a
	sbc hl, de
	call DRAW
	jp __LABEL13
__LABEL12:
	ld a, (ix-3)
	sub 202
	jp nz, __LABEL14
	ld l, (ix-5)
	ld h, (ix-4)
	ld a, (hl)
	ld l, a
	ld h, 0
	ld (ix-15), l
	ld (ix-14), h
	ld l, (ix-5)
	ld h, (ix-4)
	inc hl
	ld a, (hl)
	ld l, a
	ld h, 0
	ld (ix-13), l
	ld (ix-12), h
	ld l, (ix-5)
	ld h, (ix-4)
	inc hl
	inc hl
	ld a, (hl)
	ld l, a
	ld h, 0
	ld (ix-21), l
	ld (ix-20), h
	ld l, (ix-5)
	ld h, (ix-4)
	inc hl
	inc hl
	inc hl
	ld (ix-5), l
	ld (ix-4), h
	ld l, (ix-13)
	ld h, (ix-12)
	ld a, l
	push af
	ld l, (ix-15)
	ld h, (ix-14)
	ld a, l
	push af
	ld l, (ix-21)
	ld h, (ix-20)
	ld a, l
	call CIRCLE
	jp __LABEL15
__LABEL14:
	ld a, (ix-3)
	sub 203
	jp nz, __LABEL16
	ld l, (ix-5)
	ld h, (ix-4)
	ld a, (hl)
	ld l, a
	ld h, 0
	ld (ix-15), l
	ld (ix-14), h
	ld l, (ix-5)
	ld h, (ix-4)
	inc hl
	ld a, (hl)
	ld l, a
	ld h, 0
	ld (ix-13), l
	ld (ix-12), h
	ld l, (ix-5)
	ld h, (ix-4)
	inc hl
	inc hl
	ld a, (hl)
	ld l, a
	ld h, 0
	ld (ix-19), l
	ld (ix-18), h
	ld l, (ix-5)
	ld h, (ix-4)
	inc hl
	inc hl
	inc hl
	ld a, (hl)
	ld l, a
	ld h, 0
	ld (ix-17), l
	ld (ix-16), h
	ld l, (ix-5)
	ld h, (ix-4)
	ld de, 4
	add hl, de
	ld a, (hl)
	ld l, a
	ld h, 0
	ld (ix-21), l
	ld (ix-20), h
	ld l, (ix-21)
	ld h, (ix-20)
	ld b, 8
__LABEL34:
	add hl, hl
	djnz __LABEL34
	ld (ix-21), l
	ld (ix-20), h
	ld l, (ix-21)
	ld h, (ix-20)
	push hl
	ld l, (ix-5)
	ld h, (ix-4)
	ld de, 5
	add hl, de
	ld a, (hl)
	ld l, a
	ld h, 0
	ex de, hl
	pop hl
	call __BOR16
	ld (ix-21), l
	ld (ix-20), h
	ld l, (ix-5)
	ld h, (ix-4)
	ld de, 6
	add hl, de
	ld (ix-5), l
	ld (ix-4), h
	ld l, (ix-21)
	ld h, (ix-20)
	push hl
	ld de, 32768
	pop hl
	or a
	sbc hl, de
	ccf
	jp nc, __LABEL18
	ld l, (ix-21)
	ld h, (ix-20)
	ld de, -32768
	add hl, de
	ld de, 0
	call __U32TOFREG
	ld hl, -26
	call __PSTOREF
	push ix
	pop hl
	ld de, -26
	add hl, de
	call __PLOADF
	push bc
	push de
	push af
	ld a, 084h
	ld de, 00020h
	ld bc, 00000h
	call __DIVF
	ld hl, -26
	call __PSTOREF
	jp __LABEL19
__LABEL18:
	ld l, (ix-21)
	ld h, (ix-20)
	ld de, 0
	call __U32TOFREG
	ld hl, -26
	call __PSTOREF
	push ix
	pop hl
	ld de, -26
	add hl, de
	call __PLOADF
	push bc
	push de
	push af
	ld a, 084h
	ld de, 00020h
	ld bc, 00000h
	call __DIVF
	ld hl, -26
	call __PSTOREF
	push ix
	pop hl
	ld de, -26
	add hl, de
	call __PLOADF
	push bc
	push de
	push af
	ld a, 081h
	ld de, 00080h
	ld bc, 00000h
	call __MULF
	ld hl, -26
	call __PSTOREF
__LABEL19:
	push ix
	pop hl
	ld de, -26
	add hl, de
	call __PLOADF
	ld hl, 01235h
	push hl
	ld hl, 0FA0Eh
	push hl
	ld h, 07Bh
	push hl
	call __MULF
	ld hl, -26
	call __PSTOREF
	ld l, (ix-13)
	ld h, (ix-12)
	ld a, l
	push af
	ld l, (ix-15)
	ld h, (ix-14)
	ld a, l
	call PLOT
	ld l, (ix-17)
	ld h, (ix-16)
	push hl
	ld l, (ix-13)
	ld h, (ix-12)
	ex de, hl
	pop hl
	or a
	sbc hl, de
	push hl
	ld l, (ix-19)
	ld h, (ix-18)
	push hl
	ld l, (ix-15)
	ld h, (ix-14)
	ex de, hl
	pop hl
	or a
	sbc hl, de
	push hl
	push ix
	pop hl
	ld de, -26
	add hl, de
	call __PLOADF
	call DRAW3
	jp __LABEL17
__LABEL16:
	ld a, (ix-3)
	sub 204
	jp nz, __LABEL20
	ld l, (ix-5)
	ld h, (ix-4)
	ld a, (hl)
	ld l, a
	ld h, 0
	ld (ix-15), l
	ld (ix-14), h
	ld l, (ix-5)
	ld h, (ix-4)
	inc hl
	ld a, (hl)
	ld l, a
	ld h, 0
	ld (ix-13), l
	ld (ix-12), h
	ld l, (ix-5)
	ld h, (ix-4)
	inc hl
	inc hl
	ld (ix-5), l
	ld (ix-4), h
	ld a, (_pattern.__DATA__ + 0)
	push af
	ld l, (ix-15)
	ld h, (ix-14)
	ld a, l
	push af
	ld l, (ix-13)
	ld h, (ix-12)
	ld a, l
	call _FloodFill
	jp __LABEL21
__LABEL20:
	ld a, (ix-3)
	sub 205
	jp nz, __LABEL23
	ld l, (ix-5)
	ld h, (ix-4)
	ld a, (hl)
	ld l, a
	ld h, 0
	ld (ix-15), l
	ld (ix-14), h
	ld l, (ix-5)
	ld h, (ix-4)
	inc hl
	ld a, (hl)
	ld l, a
	ld h, 0
	ld (ix-13), l
	ld (ix-12), h
	ld l, (ix-5)
	ld h, (ix-4)
	inc hl
	inc hl
	ld (ix-5), l
	ld (ix-4), h
	ld l, (ix-15)
	ld h, (ix-14)
	ld a, l
	push af
	ld l, (ix-13)
	ld h, (ix-12)
	ld a, l
	call PRINT_AT
	ld hl, __LABEL24
	xor a
	call __PRINTSTR
__LABEL23:
__LABEL21:
__LABEL17:
__LABEL15:
__LABEL13:
__LABEL5:
	jp __LABEL0
__LABEL1:
__LABEL25:
	ld l, (ix-7)
	ld h, (ix-6)
	push hl
	ld de, 23296
	pop hl
	or a
	sbc hl, de
	jp nc, __LABEL26
	ld l, (ix-5)
	ld h, (ix-4)
	ld a, (hl)
	ld (ix-1), a
	ld l, (ix-7)
	ld h, (ix-6)
	inc hl
	push hl
	ld de, 23296
	pop hl
	or a
	sbc hl, de
	jp nc, __LABEL27
	ld l, (ix-5)
	ld h, (ix-4)
	inc hl
	ld a, (hl)
	ld (ix-2), a
	sub (ix-1)
	jp nz, __LABEL29
	ld l, (ix-5)
	ld h, (ix-4)
	inc hl
	inc hl
	ld a, (hl)
	ld l, a
	ld h, 0
	ld (ix-9), l
	ld (ix-8), h
	ld l, (ix-9)
	ld h, (ix-8)
	inc hl
	inc hl
	ld (ix-9), l
	ld (ix-8), h
	ld l, (ix-9)
	ld h, (ix-8)
	ld (ix-11), l
	ld (ix-10), h
__LABEL31:
	ld l, (ix-9)
	ld h, (ix-8)
	push hl
	ld hl, 0
	pop de
	or a
	sbc hl, de
	jp nc, __LABEL32
	ld l, (ix-7)
	ld h, (ix-6)
	push hl
	ld a, (ix-1)
	pop hl
	ld (hl), a
	ld l, (ix-9)
	ld h, (ix-8)
	dec hl
	ld (ix-9), l
	ld (ix-8), h
	ld l, (ix-7)
	ld h, (ix-6)
	inc hl
	ld (ix-7), l
	ld (ix-6), h
	jp __LABEL31
__LABEL32:
	ld l, (ix-5)
	ld h, (ix-4)
	inc hl
	inc hl
	inc hl
	ld (ix-5), l
	ld (ix-4), h
	jp __LABEL30
__LABEL29:
	ld l, (ix-7)
	ld h, (ix-6)
	push hl
	ld a, (ix-1)
	pop hl
	ld (hl), a
	ld l, (ix-7)
	ld h, (ix-6)
	inc hl
	ld (ix-7), l
	ld (ix-6), h
	ld l, (ix-5)
	ld h, (ix-4)
	inc hl
	ld (ix-5), l
	ld (ix-4), h
__LABEL30:
	jp __LABEL28
__LABEL27:
	ld l, (ix-7)
	ld h, (ix-6)
	push hl
	ld a, (ix-1)
	pop hl
	ld (hl), a
	ld l, (ix-7)
	ld h, (ix-6)
	inc hl
	ld (ix-7), l
	ld (ix-6), h
	ld l, (ix-5)
	ld h, (ix-4)
	inc hl
	ld (ix-5), l
	ld (ix-4), h
__LABEL28:
	jp __LABEL25
__LABEL26:
_Dibujar__leave:
	ld sp, ix
	pop ix
	exx
	pop hl
	ex (sp), hl
	exx
	ret
_FloodFill:
#line 199
		ld d, a
		pop hl
		pop bc
		ld e, b
		pop bc
		push hl
		push bc
fill:
		ld l,255
		push hl
nextrun:
		ld a,d
		and 7
		inc a
		ld b,a
		ld a,1
bitpos:
		rrca
		djnz bitpos
		ld c,b
		ld b,a
seekleft:
		ld a,d
		or a
		jr z,goright
		dec d
		rlc b
		call scrpos
		jr nz,seekleft
seekright:
		rrc b
		inc d
		jr z,rightedge
goright:
		call scrpos
		jr z,rightedge
		ld (hl),a
		inc e
		call checkadj
		dec e
		dec e
		call checkadj
		inc e
		jr seekright
rightedge:
		pop de
		ld a,e
		inc a
		jr nz,nextrun
		pop bc
		ret
scrpos:
		ld a,e
		and 248
		rra
		scf
		rra
		rra
		ld l,a
		xor e
		and 248
		xor e
		ld h,a
		ld a,l
		xor d
		and 7
		xor d
		rrca
		rrca
		rrca
		ld l,a
		ld a,b
		or (hl)
		cp (hl)
		ret
checkadj:
		sla c
		ld a,e
		cp 192
		ret nc
		call scrpos+1
		ret z
		inc c
		bit 2,c
		ret nz
		pop hl
		push de
		jp (hl)
#line 287
_FloodFill__leave:
	ret
__LABEL24:
	DEFW 0001h
	DEFB 20h
#line 1 "bor16.asm"

; vim:ts=4:et:
	; FASTCALL bitwise or 16 version.
	; result in HL
; __FASTCALL__ version (operands: A, H)
	; Performs 16bit or 16bit and returns the boolean
; Input: HL, DE
; Output: HL <- HL OR DE

__BOR16:
		ld a, h
		or d
	    ld h, a

	    ld a, l
	    or e
	    ld l, a

	    ret

#line 866 "VecttyRenderer.zxbas"
#line 1 "circle.asm"

	; Bresenham's like circle algorithm
	; best known as Middle Point Circle drawing algorithm

#line 1 "error.asm"

	; Simple error control routines
; vim:ts=4:et:

	ERR_NR    EQU    23610    ; Error code system variable


	; Error code definitions (as in ZX spectrum manual)

; Set error code with:
	;    ld a, ERROR_CODE
	;    ld (ERR_NR), a


	ERROR_Ok                EQU    -1
	ERROR_SubscriptWrong    EQU     2
	ERROR_OutOfMemory       EQU     3
	ERROR_OutOfScreen       EQU     4
	ERROR_NumberTooBig      EQU     5
	ERROR_InvalidArg        EQU     9
	ERROR_IntOutOfRange     EQU    10
	ERROR_NonsenseInBasic   EQU    11
	ERROR_InvalidFileName   EQU    14
	ERROR_InvalidColour     EQU    19
	ERROR_BreakIntoProgram  EQU    20
	ERROR_TapeLoadingErr    EQU    26


	; Raises error using RST #8
__ERROR:
	    ld (__ERROR_CODE), a
	    rst 8
__ERROR_CODE:
	    nop
	    ret

	; Sets the error system variable, but keeps running.
	; Usually this instruction if followed by the END intermediate instruction.
__STOP:
	    ld (ERR_NR), a
	    ret
#line 5 "circle.asm"
#line 1 "plot.asm"

	; MIXED __FASTCAL__ / __CALLE__ PLOT Function
	; Plots a point into the screen calling the ZX ROM PLOT routine

	; Y in A (accumulator)
	; X in top of the stack


#line 1 "in_screen.asm"

#line 1 "sposn.asm"

	; Printing positioning library.
			PROC
			LOCAL ECHO_E

__LOAD_S_POSN:		; Loads into DE current ROW, COL print position from S_POSN mem var.
			ld de, (S_POSN)
			ld hl, (MAXX)
			or a
			sbc hl, de
			ex de, hl
			ret


__SAVE_S_POSN:		; Saves ROW, COL from DE into S_POSN mem var.
			ld hl, (MAXX)
			or a
			sbc hl, de
			ld (S_POSN), hl ; saves it again
			ret


	ECHO_E	EQU 23682
	MAXX	EQU ECHO_E   ; Max X position + 1
	MAXY	EQU MAXX + 1 ; Max Y position + 1

	S_POSN	EQU 23688
	POSX	EQU S_POSN		; Current POS X
	POSY	EQU S_POSN + 1	; Current POS Y

			ENDP

#line 2 "in_screen.asm"


__IN_SCREEN:
		; Returns NO carry if current coords (D, E)
		; are OUT of the screen limits (MAXX, MAXY)

		PROC
		LOCAL __IN_SCREEN_ERR

		ld hl, MAXX
		ld a, e
		cp (hl)
		jr nc, __IN_SCREEN_ERR	; Do nothing and return if out of range

		ld a, d
		inc hl
		cp (hl)
		;; jr nc, __IN_SCREEN_ERR	; Do nothing and return if out of range
		;; ret
	    ret c                       ; Return if carry (OK)

__IN_SCREEN_ERR:
__OUT_OF_SCREEN_ERR:
		; Jumps here if out of screen
		ld a, ERROR_OutOfScreen
	    jp __STOP   ; Saves error code and exits

		ENDP
#line 9 "plot.asm"
#line 1 "cls.asm"

	; JUMPS directly to spectrum CLS
	; This routine does not clear lower screen

	;CLS	EQU	0DAFh

	; Our faster implementation



CLS:
		PROC

		LOCAL COORDS
		LOCAL __CLS_SCR
		LOCAL ATTR_P
		LOCAL SCREEN

		ld hl, 0
		ld (COORDS), hl
	    ld hl, 1821h
		ld (S_POSN), hl
__CLS_SCR:
		ld hl, SCREEN
		ld (hl), 0
		ld d, h
		ld e, l
		inc de
		ld bc, 6144
		ldir

		; Now clear attributes

		ld a, (ATTR_P)
		ld (hl), a
		ld bc, 767
		ldir
		ret

	COORDS	EQU	23677
	SCREEN	EQU 16384 ; Default start of the screen (can be changed)
	ATTR_P	EQU 23693
	;you can poke (SCREEN_SCRADDR) to change CLS, DRAW & PRINTing address

	SCREEN_ADDR EQU (__CLS_SCR + 1) ; Address used by print and other screen routines
								    ; to get the start of the screen
		ENDP

#line 10 "plot.asm"
#line 1 "attr.asm"

	; Attribute routines
; vim:ts=4:et:sw:




#line 1 "const.asm"

	; Global constants

	P_FLAG	EQU 23697
	FLAGS2	EQU 23681
	ATTR_P	EQU 23693	; permanet ATTRIBUTES
	ATTR_T	EQU 23695	; temporary ATTRIBUTES
	CHARS	EQU 23606 ; Pointer to ROM/RAM Charset
	UDG	EQU 23675 ; Pointer to UDG Charset
	MEM0	EQU 5C92h ; Temporary memory buffer used by ROM chars

#line 8 "attr.asm"


__ATTR_ADDR:
	    ; calc start address in DE (as (32 * d) + e)
    ; Contributed by Santiago Romero at http://www.speccy.org
	    ld h, 0                     ;  7 T-States
	    ld a, d                     ;  4 T-States
	    add a, a     ; a * 2        ;  4 T-States
	    add a, a     ; a * 4        ;  4 T-States
	    ld l, a      ; HL = A * 4   ;  4 T-States

	    add hl, hl   ; HL = A * 8   ; 15 T-States
	    add hl, hl   ; HL = A * 16  ; 15 T-States
	    add hl, hl   ; HL = A * 32  ; 15 T-States

    ld d, 18h ; DE = 6144 + E. Note: 6144 is the screen size (before attr zone)
	    add hl, de

	    ld de, (SCREEN_ADDR)    ; Adds the screen address
	    add hl, de

	    ; Return current screen address in HL
	    ret


	; Sets the attribute at a given screen coordinate (D, E).
	; The attribute is taken from the ATTR_T memory variable
	; Used by PRINT routines
SET_ATTR:

	    ; Checks for valid coords
	    call __IN_SCREEN
	    ret nc

__SET_ATTR:
	    ; Internal __FASTCALL__ Entry used by printing routines
	    PROC

	    call __ATTR_ADDR

__SET_ATTR2:  ; Sets attr from ATTR_T to (HL) which points to the scr address
	    ld de, (ATTR_T)    ; E = ATTR_T, D = MASK_T

	    ld a, d
	    and (hl)
	    ld c, a    ; C = current screen color, masked

	    ld a, d
	    cpl        ; Negate mask
	    and e    ; Mask current attributes
	    or c    ; Mix them
	    ld (hl), a ; Store result in screen

	    ret

	    ENDP


	; Sets the attribute at a given screen pixel address in hl
	; HL contains the address in RAM for a given pixel (not a coordinate)
SET_PIXEL_ADDR_ATTR:
	    ;; gets ATTR position with offset given in SCREEN_ADDR
	    ld a, h
	    rrca
	    rrca
	    rrca
	    and 3
	    or 18h
	    ld h, a
	    ld de, (SCREEN_ADDR)
	    add hl, de  ;; Final screen addr
	    jp __SET_ATTR2
#line 11 "plot.asm"

PLOT:
		PROC

		LOCAL PLOT_SUB
		LOCAL PIXEL_ADDR
		LOCAL COORDS
		LOCAL __PLOT_ERR
	    LOCAL P_FLAG
	    LOCAL __PLOT_OVER1

	P_FLAG EQU 23697

		pop hl
		ex (sp), hl ; Callee

		ld b, a
		ld c, h

		ld a, 191
		cp b
		jr c, __PLOT_ERR ; jr is faster here (#1)

__PLOT:			; __FASTCALL__ entry (b, c) = pixel coords (y, x)
		ld (COORDS), bc	; Saves current point
		ld a, 191 ; Max y coord
		call PIXEL_ADDR
	    res 6, h    ; Starts from 0
	    ld bc, (SCREEN_ADDR)
	    add hl, bc  ; Now current offset

	    ld b, a
	    inc b
	    ld a, 0FEh
	LOCAL __PLOT_LOOP
__PLOT_LOOP:
	    rrca
	    djnz __PLOT_LOOP

	    ld b, a
	    ld a, (P_FLAG)
	    ld c, a
	    ld a, (hl)
	    bit 0, c        ; is it OVER 1
	    jr nz, __PLOT_OVER1
	    and b

__PLOT_OVER1:
	    bit 2, c        ; is it inverse 1
	    jr nz, __PLOT_END

	    xor b
	    cpl

	LOCAL __PLOT_END
__PLOT_END:
	    ld (hl), a
	    jp SET_PIXEL_ADDR_ATTR

__PLOT_ERR:
	    jp __OUT_OF_SCREEN_ERR ; Spent 3 bytes, but saves 3 T-States at (#1)

	PLOT_SUB EQU 22ECh
	PIXEL_ADDR EQU 22ACh
	COORDS EQU 5C7Dh
		ENDP
#line 6 "circle.asm"


	; Draws a circle at X, Y of radius R
	; X, Y on the Stack, R in accumulator (Byte)

			PROC
			LOCAL __CIRCLE_ERROR
			LOCAL __CIRCLE_LOOP
			LOCAL __CIRCLE_NEXT

__CIRCLE_ERROR:
	        jp __OUT_OF_SCREEN_ERR
	;; __CIRCLE_ERROR EQU __OUT_OF_SCREEN_ERR
;; __CIRCLE_ERROR:
	;; 		; Jumps here if out of screen
	;; 		scf ; Always sets carry Flag
	;;
	;; 		ld a, ERROR_OutOfScreen
	;; 		ld (ERR_NR), a
	;; 		ret
CIRCLE:
	        ;; Entry point
			pop hl	; Return Address
			pop de	; D = Y
			ex (sp), hl ; __CALLEE__ convention
			ld e, h ; E = X


			ld h, a ; H = R
			add a, d
			sub 192
			jr nc, __CIRCLE_ERROR

			ld a, d
			sub h
			jr c, __CIRCLE_ERROR

			ld a, e
			sub h
			jr c, __CIRCLE_ERROR

			ld a, h
			add a, e
			jr c, __CIRCLE_ERROR


; __FASTCALL__ Entry: D, E = Y, X point of the center
	; A = Radious
__CIRCLE:
			push de
			ld a, h
			exx
			pop de		; D'E' = x0, y0
			ld h, a		; H' = r

			ld c, e
			ld a, h
			add a, d
			ld b, a
			call __CIRCLE_PLOT	; PLOT (x0, y0 + r)

			ld b, d
			ld a, h
			add a, e
			ld c, a
			call __CIRCLE_PLOT	; PLOT (x0 + r, y0)

			ld c, e
			ld a, d
			sub h
			ld b, a
			call __CIRCLE_PLOT ; PLOT (x0, y0 - r)

			ld b, d
			ld a, e
			sub h
			ld c, a
			call __CIRCLE_PLOT ; PLOT (x0 - r, y0)

			exx
			ld b, 0		; B = x = 0
			ld c, h		; C = y = Radius
			ld hl, 1
			or a
			sbc hl, bc	; HL = f = 1 - radius

			ex de, hl
			ld hl, 0
			or a
			sbc hl, bc  ; HL = -radius
			add hl, hl	; HL = -2 * radius
			ex de, hl	; DE = -2 * radius = ddF_y, HL = f

			xor a		; A = ddF_x = 0
			ex af, af'	; Saves it

__CIRCLE_LOOP:
			ld a, b
			cp c
			ret nc		; Returns when x >= y

		bit 7, h	; HL >= 0? : if (f >= 0)...
			jp nz, __CIRCLE_NEXT

			dec c		; y--
			inc de
			inc de		; ddF_y += 2

			add hl, de	; f += ddF_y

__CIRCLE_NEXT:
			inc b		; x++
			ex af, af'
			add a, 2	; 1 Cycle faster than inc a, inc a

			inc hl		; f++
			push af
			add a, l
			ld l, a
			ld a, h
			adc a, 0	; f = f + ddF_x
			ld h, a
			pop af
			ex af, af'

			push bc
			exx
			pop hl		; H'L' = Y, X

			ld a, d
			add a, h
			ld b, a		; B = y0 + y
			ld a, e
			add a, l
			ld c, a		; C = x0 + x
			call __CIRCLE_PLOT ; plot(x0 + x, y0 + y)

			ld a, d
			add a, h
			ld b, a		; B = y0 + y
			ld a, e
			sub l
			ld c, a		; C = x0 - x
			call __CIRCLE_PLOT ; plot(x0 - x, y0 + y)

			ld a, d
			sub h
			ld b, a		; B = y0 - y
			ld a, e
			add a, l
			ld c, a		; C = x0 + x
			call __CIRCLE_PLOT ; plot(x0 + x, y0 - y)

			ld a, d
			sub h
			ld b, a		; B = y0 - y
			ld a, e
			sub l
			ld c, a		; C = x0 - x
			call __CIRCLE_PLOT ; plot(x0 - x, y0 - y)

			ld a, d
			add a, l
			ld b, a		; B = y0 + x
			ld a, e
			add a, h
			ld c, a		; C = x0 + y
			call __CIRCLE_PLOT ; plot(x0 + y, y0 + x)

			ld a, d
			add a, l
			ld b, a		; B = y0 + x
			ld a, e
			sub h
			ld c, a		; C = x0 - y
			call __CIRCLE_PLOT ; plot(x0 - y, y0 + x)

			ld a, d
			sub l
			ld b, a		; B = y0 - x
			ld a, e
			add a, h
			ld c, a		; C = x0 + y
			call __CIRCLE_PLOT ; plot(x0 + y, y0 - x)

			ld a, d
			sub l
			ld b, a		; B = y0 - x
			ld a, e
			sub h
			ld c, a		; C = x0 + y
			call __CIRCLE_PLOT ; plot(x0 - y, y0 - x)

			exx
			jp __CIRCLE_LOOP



__CIRCLE_PLOT:
			; Plots a point of the circle, preserving HL and DE
			push hl
			push de
			call __PLOT
			pop de
			pop hl
			ret

			ENDP
#line 867 "VecttyRenderer.zxbas"
#line 1 "divf.asm"

#line 1 "stackf.asm"

	; -------------------------------------------------------------
	; Functions to manage FP-Stack of the ZX Spectrum ROM CALC
	; -------------------------------------------------------------


	__FPSTACK_PUSH EQU 2AB6h	; Stores an FP number into the ROM FP stack (A, ED CB)
	__FPSTACK_POP  EQU 2BF1h	; Pops an FP number out of the ROM FP stack (A, ED CB)

__FPSTACK_PUSH2: ; Pushes Current A ED CB registers and top of the stack on (SP + 4)
	                 ; Second argument to push into the stack calculator is popped out of the stack
	                 ; Since the caller routine also receives the parameters into the top of the stack
	                 ; four bytes must be removed from SP before pop them out

	    call __FPSTACK_PUSH ; Pushes A ED CB into the FP-STACK
	    exx
	    pop hl       ; Caller-Caller return addr
	    exx
	    pop hl       ; Caller return addr

	    pop af
	    pop de
	    pop bc

	    push hl      ; Caller return addr
	    exx
	    push hl      ; Caller-Caller return addr
	    exx

	    jp __FPSTACK_PUSH


__FPSTACK_I16:	; Pushes 16 bits integer in HL into the FP ROM STACK
					; This format is specified in the ZX 48K Manual
					; You can push a 16 bit signed integer as
					; 0 SS LL HH 0, being SS the sign and LL HH the low
					; and High byte respectively
		ld a, h
		rla			; sign to Carry
		sbc	a, a	; 0 if positive, FF if negative
		ld e, a
		ld d, l
		ld c, h
		xor a
		ld b, a
		jp __FPSTACK_PUSH
#line 2 "divf.asm"


	; -------------------------------------------------------------
	; Floating point library using the FP ROM Calculator (ZX 48K)

	; All of them uses C EDHL registers as 1st paramter.
	; For binary operators, the 2n operator must be pushed into the
	; stack, in the order BC DE HL (B not used).
	;
	; Uses CALLEE convention
	; -------------------------------------------------------------

__DIVF:	; Division
		PROC
		LOCAL __DIVBYZERO
		LOCAL TMP, ERR_SP

	TMP         EQU 23629 ;(DEST)
	ERR_SP      EQU 23613

		call __FPSTACK_PUSH2

		ld hl, (ERR_SP)
		ld (TMP), hl
		ld hl, __DIVBYZERO
		push hl
		ld hl, 0
		add hl, sp
		ld (ERR_SP), hl

		; ------------- ROM DIV
		rst 28h
		defb 01h	; EXCHANGE
		defb 05h	; DIV
		defb 38h;   ; END CALC

		pop hl
		ld hl, (TMP)
		ld (ERR_SP), hl

		jp __FPSTACK_POP

__DIVBYZERO:
		ld hl, (TMP)
		ld (ERR_SP), hl

		ld a, ERROR_NumberTooBig
		ld (ERR_NR), a

		; Returns 0 on DIV BY ZERO error
		xor a
		ld b, a
		ld c, a
		ld d, a
		ld e, a
		ret

		ENDP

#line 868 "VecttyRenderer.zxbas"
#line 1 "draw.asm"

	; DRAW using bresenhams algorithm and screen positioning
; Copyleft (k) 2010 by J. Rodriguez (a.k.a. Boriel) http://www.boriel.com
; vim:ts=4:et:sw=4:

	; Y parameter in A
	; X parameter in high byte on top of the stack







#line 1 "PixelDown.asm"

	;
	; PixelDown
	; Alvin Albrecht 2002
	;

	; Pixel Down
	;
	; Adjusts screen address HL to move one pixel down in the display.
	; (0,0) is located at the top left corner of the screen.
	;
; enter: HL = valid screen address
; exit : Carry = moved off screen
	;        Carry'= moved off current cell (needs ATTR update)
	;        HL = moves one pixel down
; used : AF, HL

SP.PixelDown:
	   inc h
	   ld a,h
	   and $07
	   ret nz
	   ex af, af'  ; Sets carry on F'
	   scf         ; which flags ATTR must be updated
	   ex af, af'
	   ld a,h
	   sub $08
	   ld h,a
	   ld a,l
	   add a,$20
	   ld l,a
	   ret nc
	   ld a,h
	   add a,$08
	   ld h,a
	;IF DISP_HIRES
	;   and $18
	;   cp $18
	;ELSE
	   cp $58
	;ENDIF
	   ccf
	   ret
#line 15 "draw.asm"
#line 1 "PixelUp.asm"

	;
	; PixelUp
	; Alvin Albrecht 2002
	;

	; Pixel Up
	;
	; Adjusts screen address HL to move one pixel up in the display.
	; (0,0) is located at the top left corner of the screen.
	;
; enter: HL = valid screen address
; exit : Carry = moved off screen
	;        HL = moves one pixel up
; used : AF, HL

SP.PixelUp:
	   ld a,h
	   dec h
	   and $07
	   ret nz
	   ex af, af'
	   scf
	   ex af, af'
	   ld a,$08
	   add a,h
	   ld h,a
	   ld a,l
	   sub $20
	   ld l,a
	   ret nc
	   ld a,h
	   sub $08
	   ld h,a
	;IF DISP_HIRES
	;   and $18
	;   cp $18
	;   ccf
	;ELSE
	   cp $40
	;ENDIF
	   ret
#line 16 "draw.asm"
#line 1 "PixelLeft.asm"

	;
	; PixelLeft
	; Jose Rodriguez 2012
	;

	; PixelLeft
	;
	; Adjusts screen address HL and Pixel bit A to move one pixel to the left
	; on the display.  Start of line set Carry (Out of Screen)
	;
; enter: HL = valid screen address
	;        A = Bit Set
; exit : Carry = moved off screen
	;        Carry' Set if moved off current ATTR CELL
	;        HL = moves one character left, if needed
	;        A = Bit Set with new pixel pos.
; used : AF, HL


SP.PixelLeft:
	    rlca    ; Sets new pixel bit 1 to the right
	    ret nc
	    ex af, af' ; Signal in C' we've moved off current ATTR cell
	    ld a,l
	    dec a
	    ld l,a
	    cp 32      ; Carry if in screen
	    ccf
	    ld a, 1
	    ret

#line 17 "draw.asm"
#line 1 "PixelRight.asm"

	;
	; PixelRight
	; Jose Rodriguez 2012
	;


	; PixelRight
	;
	; Adjusts screen address HL and Pixel bit A to move one pixel to the left
	; on the display.  Start of line set Carry (Out of Screen)
	;
; enter: HL = valid screen address
	;        A = Bit Set
; exit : Carry = moved off screen
	;        Carry' Set if moved off current ATTR CELL
	;        HL = moves one character left, if needed
	;        A = Bit Set with new pixel pos.
; used : AF, HL


SP.PixelRight:
	    rrca    ; Sets new pixel bit 1 to the right
	    ret nc
	    ex af, af' ; Signal in C' we've moved off current ATTR cell
	    ld a, l
	    inc a
	    ld l, a
	    cp 32      ; Carry if IN screen
	    ccf
	    ld a, 80h
	    ret

#line 18 "draw.asm"

	;; DRAW PROCEDURE
	    PROC

	    LOCAL __DRAW1
	    LOCAL __DRAW2
	    LOCAL __DRAW3
	    LOCAL __DRAW4, __DRAW4_LOOP
	    LOCAL __DRAW5
	    LOCAL __DRAW6, __DRAW6_LOOP
	    LOCAL __DRAW_ERROR
	    LOCAL DX1, DX2, DY1, DY2
	    LOCAL __INCX, __INCY, __DECX, __DECY
	    LOCAL P_FLAG
	P_FLAG EQU 23697

__DRAW_ERROR:
	    jp __OUT_OF_SCREEN_ERR

DRAW:
	    ;; ENTRY POINT

	    LOCAL COORDS
	    LOCAL __DRAW_SETUP1, __DRAW_START, __PLOTOVER, __PLOTINVERSE

	    ex de, hl ; DE = Y OFFSET
	    pop hl	; return addr
	    ex (sp), hl ; CALLEE => HL = X OFFSET
	    ld bc, (COORDS)

	    ld a, c
	    add a, l
	    ld l, a
	    ld a, h
	    adc a, 0 ; HL = HL + C
	    ld h, a
	    jr nz, __DRAW_ERROR	; if a <> 0 => Out of Screen

	    ld a, b
	    add a, e
	    ld e, a
	    ld a, d
	    adc a, 0 ; DE = DE + B
	    ld d, a
	    jr nz, __DRAW_ERROR	; if a <> 0 => Out of Screen

	    ld a, 191
	    sub e
	    jr c, __DRAW_ERROR	; Out of screen

	    ld h, e			; now H,L = y2, x2

__DRAW:
	    ; __FASTCALL__ Entry. Plots from (COORDS) to coord H, L
	    push hl
	    ex de, hl		; D,E = y2, x2;

	    ld a, (P_FLAG)
	    ld c, a
	    bit 2, a        ; Test for INVERSE1
	    jr z, __DRAW_SETUP1
	    ld a, 2Fh       ; CPL
	    ld (__PLOTINVERSE), a
	    ld a, 0A6h      ; and (hl)
	    jp __DRAW_START

__DRAW_SETUP1:
	    xor a           ; nop
	    ld (__PLOTINVERSE), a
	    ld a, 0B6h      ; or (hl)
	    bit 0, c        ; Test for OVER
	    jr z, __DRAW_START
	    ld a, 0AEh      ; xor (hl)

__DRAW_START:
	    ld (__PLOTOVER), a ; "Pokes" last operation
	    exx
	    ld bc, (COORDS) ; B'C' = y1, x1
	    ld d, b         ; Saves B' in D'
	    ld a, 191
	    LOCAL __PIXEL_ADDR
	__PIXEL_ADDR EQU 22ACh
	    call __PIXEL_ADDR

	    ;; Now gets pixel mask in A register
	    ld b, a
	    inc b
	    xor a
	    scf
	    LOCAL __PIXEL_MASK
__PIXEL_MASK:
	    rra
	    djnz __PIXEL_MASK

	    ld b, d         ; Restores B' from D'
	    pop de			; D'E' = y2, x2
    exx             ; At this point: D'E' = y2,x2 coords
	                    ; B'C' = y1, y1  coords
	    ex af, af'      ; Saves A reg for later
	                    ; A' = Pixel mask
	                    ; H'L' = Screen Address of pixel

	    ld bc, (COORDS) ; B,C = y1, x1

	    ld a, e
	    sub c			; dx = X2 - X1
	    ld c, a			; Saves dx in c

	    ld a, 0Ch       ; INC C opcode
	    ld hl, __INCX   ; xi = 1
	    jr nc, __DRAW1

	    ld a, c
	    neg		 		; dx = X1 - X2
	    ld c, a
	    ld a, 0Dh       ; DEC C opcode
	    ld hl, __DECX   ; xi = -1

__DRAW1:
	    ld (DX1), a
	    ld (DX1 + 2), hl ; Updates DX1 call address
	    ld (DX2), a
	    ld (DX2 + 2), hl ; Updates DX2 call address

	    ld a, d
	    sub b			; dy = Y2 - Y1
	    ld b, a			; Saves dy in b

	    ld a, 4         ; INC B opcode
	    ld hl, __INCY   ; y1 = 1
	    jr nc, __DRAW2

	    ld a, b
	    neg
	    ld b, a         ; dy = Y2 - Y1
	    ld a, 5         ; DEC B opcode
	    ld hl, __DECY   ; y1 = -1

__DRAW2:
	    ld (DY1), a
	    ld (DY1 + 2), hl ; Updates DX1 call address
	    ld (DY2), a
	    ld (DY2 + 2), hl ; Updates DX2 call address

	    ld a, b
	    sub c			; dy - dx
	    jr c, __DRAW_DX_GT_DY	; DX > DY

	    ; At this point DY >= DX
	    ; --------------------------
	    ; HL = error = dY / 2
	    ld h, 0
	    ld l, b
	    srl l

	    ; DE = -dX
	    xor a
	    sub c
	    ld e, a
	    sbc a, a
	    ld d, a

	    ; BC = DY
	    ld c, b
	    ld b, h

	    exx
	    scf             ; Sets Carry to signal update ATTR
	    ex af, af'      ; Brings back pixel mask
	    ld e, a         ; Saves it in free E register
	    jp __DRAW4_LOOP

__DRAW3:			; While c != e => while y != y2
	    exx
	    add hl, de		; error -= dX
	    bit 7, h		;
	    exx				; recover coordinates
	    jr z, __DRAW4	; if error < 0

	    exx
	    add hl, bc		; error += dY
	    exx

	    ld a, e
DX1:                ; x += xi
	    inc c
	    call __INCX     ; This address will be dynamically updated
	    ld e, a

__DRAW4:

DY1:                ; y += yi
	    inc b
	    call __INCY     ; This address will be dynamically updated
	    ld a, e         ; Restores A reg.
	    call __FASTPLOT

__DRAW4_LOOP:
	    ld a, b
	    cp d
	    jp nz, __DRAW3
	    ld (COORDS), bc
	    ret

__DRAW_DX_GT_DY:	; DX > DY
	    ; --------------------------
	    ; HL = error = dX / 2
	    ld h, 0
	    ld l, c
	    srl l			; HL = error = DX / 2

	    ; DE = -dY
	    xor a
	    sub b
	    ld e, a
	    sbc a, a
	    ld d, a

	    ; BC = dX
	    ld b, h

	    exx
	    ld d, e
	    scf             ; Sets Carry to signal update ATTR
	    ex af, af'      ; Brings back pixel mask
	    ld e, a         ; Saves it in free E register
	    jp __DRAW6_LOOP

__DRAW5:			; While loop
	    exx
	    add hl, de		; error -= dY
	    bit 7, h		; if (error < 0)
	    exx				; Restore coords
	    jr z, __DRAW6	;
	    exx
	    add hl, bc		; error += dX
	    exx

DY2:                ; y += yi
	    inc b
	    call __INCY     ; This address will be dynamically updated

__DRAW6:
	    ld a, e
DX2:                ; x += xi
	    inc c
	    call __INCX     ; This address will be dynamically updated
	    ld e, a
	    call __FASTPLOT

__DRAW6_LOOP:
	    ld a, c			; Current X coord
	    cp d
	    jp nz, __DRAW5
	    ld (COORDS), bc
	    ret

	COORDS   EQU 5C7Dh

__DRAW_END:
	    exx
	    ret

	    ;; Given a A mask and an HL screen position
	    ;; return the next left position
	    ;; Also updates BC coords
	__DECX EQU SP.PixelLeft

	    ;; Like the above, but to the RIGHT
	    ;; Also updates BC coords
	__INCX EQU SP.PixelRight

	    ;; Given an HL screen position, calculates
	    ;; the above position
	    ;; Also updates BC coords
	__INCY EQU SP.PixelUp

	    ;; Given an HL screen position, calculates
	    ;; the above position
	    ;; Also updates BC coords
	__DECY EQU SP.PixelDown

	    ;; Puts the A register MASK in (HL)
__FASTPLOT:
__PLOTINVERSE:
	    nop         ; Replace with CPL if INVERSE 1
__PLOTOVER:
	    or (hl)     ; Replace with XOR (hl) if OVER 1 AND INVERSE 0
	                ; Replace with AND (hl) if INVERSE 1

	    ld (hl), a
	    ex af, af'  ; Recovers flag. If Carry set => update ATTR
	    ld a, e     ; Recovers A reg
	    ret nc

	    push hl
	    push de
	    push bc
	    call SET_PIXEL_ADDR_ATTR
	    pop bc
	    pop de
	    pop hl

	    LOCAL __FASTPLOTEND
__FASTPLOTEND:
	    or a        ; Resets carry flag
	    ex af, af'  ; Recovers A reg
	    ld a, e
	    ret

	    ENDP

#line 869 "VecttyRenderer.zxbas"
#line 1 "draw3.asm"

	; -----------------------------------------------------------
; vim: et:ts=4:sw=4:ruler:
	;
	; DRAW an arc using ZX ROM algorithm.
	; DRAW x, y, r => r = Arc in radians

	; r parameter in A ED BC register
	; X, and Y parameter in high byte on top of the stack






	; Ripped from the ZX Spectrum ROM

DRAW3:
	        PROC
	        LOCAL STACK_TO_BC
	        LOCAL STACK_TO_A
	        LOCAL COORDS
	        LOCAL L2477
	        LOCAL L2420
	        LOCAL L2439
	        LOCAL L245F
	        LOCAL L23C1
	        LOCAL L2D28
	        LOCAL SUM_C, SUM_B

	L2D28   EQU 02D28h
	COORDS  EQU 5C7Dh
	STACK_TO_BC EQU 2307h
	STACK_TO_A  EQU 2314h

	        exx
	        ex af, af'              ;; Preserves ARC
	        pop hl
	        pop de
	        ex (sp), hl             ;; CALLEE
	        push de
	        call __FPSTACK_I16      ;; X Offset
	        pop hl
	        call __FPSTACK_I16      ;; Y Offset
	        exx
	        ex af, af'
	        call __FPSTACK_PUSH     ;; R Arc

	;   Now enter the calculator and store the complete rotation angle in mem-5

	        RST     28H             ;; FP-CALC      x, y, A.
	        DEFB    $C5             ;;st-mem-5      x, y, A.

	;   Test the angle for the special case of 360 degrees.

	        DEFB    $A2             ;;stk-half      x, y, A, 1/2.
	        DEFB    $04             ;;multiply      x, y, A/2.
	        DEFB    $1F             ;;sin           x, y, sin(A/2).
	        DEFB    $31             ;;duplicate     x, y, sin(A/2),sin(A/2)
	        DEFB    $30             ;;not           x, y, sin(A/2), (0/1).
	        DEFB    $30             ;;not           x, y, sin(A/2), (1/0).
	        DEFB    $00             ;;jump-true     x, y, sin(A/2).

	        DEFB    $06             ;;forward to L23A3, DR-SIN-NZ
	                                ;;if sin(r/2) is not zero.

	;   The third parameter is 2*PI (or a multiple of 2*PI) so a 360 degrees turn
	;   would just be a straight line.  Eliminating this case here prevents
	;   division by zero at later stage.

	        DEFB    $02             ;;delete        x, y.
	        DEFB    $38             ;;end-calc      x, y.
	        JP      L2477

	; ---

	;   An arc can be drawn.

	;; DR-SIN-NZ
	        DEFB    $C0             ;;st-mem-0      x, y, sin(A/2).   store mem-0
	        DEFB    $02             ;;delete        x, y.

	;   The next step calculates (roughly) the diameter of the circle of which the
	;   arc will form part.  This value does not have to be too accurate as it is
	;   only used to evaluate the number of straight lines and then discarded.
	;   After all for a circle, the radius is used. Consequently, a circle of
	;   radius 50 will have 24 straight lines but an arc of radius 50 will have 20
	;   straight lines - when drawn in any direction.
	;   So that simple arithmetic can be used, the length of the chord can be
	;   calculated as X+Y rather than by Pythagoras Theorem and the sine of the
	;   nearest angle within reach is used.

	        DEFB    $C1             ;;st-mem-1      x, y.             store mem-1
	        DEFB    $02             ;;delete        x.

	        DEFB    $31             ;;duplicate     x, x.
	        DEFB    $2A             ;;abs           x, x (+ve).
	        DEFB    $E1             ;;get-mem-1     x, X, y.
	        DEFB    $01             ;;exchange      x, y, X.
	        DEFB    $E1             ;;get-mem-1     x, y, X, y.
	        DEFB    $2A             ;;abs           x, y, X, Y (+ve).
	        DEFB    $0F             ;;addition      x, y, X+Y.
	        DEFB    $E0             ;;get-mem-0     x, y, X+Y, sin(A/2).
	        DEFB    $05             ;;division      x, y, X+Y/sin(A/2).
	        DEFB    $2A             ;;abs           x, y, X+Y/sin(A/2) = D.

	;    Bring back sin(A/2) from mem-0 which will shortly get trashed.
	;    Then bring D to the top of the stack again.

	        DEFB    $E0             ;;get-mem-0     x, y, D, sin(A/2).
	        DEFB    $01             ;;exchange      x, y, sin(A/2), D.

	;   Note. that since the value at the top of the stack has arisen as a result
	;   of division then it can no longer be in integer form and the next re-stack
	;   is unnecessary. Only the Sinclair ZX80 had integer division.

	        ;;DEFB    $3D             ;;re-stack      (unnecessary)

	        DEFB    $38             ;;end-calc      x, y, sin(A/2), D.

	;   The next test avoids drawing 4 straight lines when the start and end pixels
	;   are adjacent (or the same) but is probably best dispensed with.

	        LD      A,(HL)          ; fetch exponent byte of D.
	        CP      $81             ; compare to 1
	        JR      NC,L23C1        ; forward, if > 1,  to DR-PRMS

	;   else delete the top two stack values and draw a simple straight line.

	        RST     28H             ;; FP-CALC
	        DEFB    $02             ;;delete
	        DEFB    $02             ;;delete
	        DEFB    $38             ;;end-calc      x, y.

	        JP      L2477           ; to LINE-DRAW

	; ---

	;   The ARC will consist of multiple straight lines so call the CIRCLE-DRAW
	;   PARAMETERS ROUTINE to pre-calculate sine values from the angle (in mem-5)
	;   and determine also the number of straight lines from that value and the
	;   'diameter' which is at the top of the calculator stack.

	;; DR-PRMS
L23C1:  CALL    247Dh           ; routine CD-PRMS1

	                                ; mem-0 ; (A)/No. of lines (=a) (step angle)
	                                ; mem-1 ; sin(a/2)
	                                ; mem-2 ; -
	                                ; mem-3 ; cos(a)                        const
	                                ; mem-4 ; sin(a)                        const
	                                ; mem-5 ; Angle of rotation (A)         in
	                                ; B     ; Count of straight lines - max 252.

	        PUSH    BC              ; Save the line count on the machine stack.

	;   Remove the now redundant diameter value D.

	        RST     28H             ;; FP-CALC      x, y, sin(A/2), D.
	        DEFB    $02             ;;delete        x, y, sin(A/2).

	;   Dividing the sine of the step angle by the sine of the total angle gives
	;   the length of the initial chord on a unary circle. This factor f is used
	;   to scale the coordinates of the first line which still points in the
	;   direction of the end point and may be larger.

	        DEFB    $E1             ;;get-mem-1     x, y, sin(A/2), sin(a/2)
	        DEFB    $01             ;;exchange      x, y, sin(a/2), sin(A/2)
	        DEFB    $05             ;;division      x, y, sin(a/2)/sin(A/2)
	        DEFB    $C1             ;;st-mem-1      x, y. f.
	        DEFB    $02             ;;delete        x, y.

	;   With the factor stored, scale the x coordinate first.

	        DEFB    $01             ;;exchange      y, x.
	        DEFB    $31             ;;duplicate     y, x, x.
	        DEFB    $E1             ;;get-mem-1     y, x, x, f.
	        DEFB    $04             ;;multiply      y, x, x*f    (=xx)
	        DEFB    $C2             ;;st-mem-2      y, x, xx.
	        DEFB    $02             ;;delete        y. x.

	;   Now scale the y coordinate.

	        DEFB    $01             ;;exchange      x, y.
	        DEFB    $31             ;;duplicate     x, y, y.
	        DEFB    $E1             ;;get-mem-1     x, y, y, f
	        DEFB    $04             ;;multiply      x, y, y*f    (=yy)

	;   Note. 'sin' and 'cos' trash locations mem-0 to mem-2 so fetch mem-2 to the
	;   calculator stack for safe keeping.

	        DEFB    $E2             ;;get-mem-2     x, y, yy, xx.

	;   Once we get the coordinates of the first straight line then the 'ROTATION
	;   FORMULA' used in the arc loop will take care of all other points, but we
	;   now use a variation of that formula to rotate the first arc through (A-a)/2
	;   radians.
	;
	;       xRotated = y * sin(angle) + x * cos(angle)
	;       yRotated = y * cos(angle) - x * sin(angle)
	;

	        DEFB    $E5             ;;get-mem-5     x, y, yy, xx, A.
	        DEFB    $E0             ;;get-mem-0     x, y, yy, xx, A, a.
	        DEFB    $03             ;;subtract      x, y, yy, xx, A-a.
	        DEFB    $A2             ;;stk-half      x, y, yy, xx, A-a, 1/2.
	        DEFB    $04             ;;multiply      x, y, yy, xx, (A-a)/2. (=angle)
	        DEFB    $31             ;;duplicate     x, y, yy, xx, angle, angle.
	        DEFB    $1F             ;;sin           x, y, yy, xx, angle, sin(angle)
	        DEFB    $C5             ;;st-mem-5      x, y, yy, xx, angle, sin(angle)
	        DEFB    $02             ;;delete        x, y, yy, xx, angle

	        DEFB    $20             ;;cos           x, y, yy, xx, cos(angle).

	;   Note. mem-0, mem-1 and mem-2 can be used again now...

	        DEFB    $C0             ;;st-mem-0      x, y, yy, xx, cos(angle).
	        DEFB    $02             ;;delete        x, y, yy, xx.

	        DEFB    $C2             ;;st-mem-2      x, y, yy, xx.
	        DEFB    $02             ;;delete        x, y, yy.

	        DEFB    $C1             ;;st-mem-1      x, y, yy.
	        DEFB    $E5             ;;get-mem-5     x, y, yy, sin(angle)
	        DEFB    $04             ;;multiply      x, y, yy*sin(angle).
	        DEFB    $E0             ;;get-mem-0     x, y, yy*sin(angle), cos(angle)
	        DEFB    $E2             ;;get-mem-2     x, y, yy*sin(angle), cos(angle), xx.
	        DEFB    $04             ;;multiply      x, y, yy*sin(angle), xx*cos(angle).
	        DEFB    $0F             ;;addition      x, y, xRotated.
	        DEFB    $E1             ;;get-mem-1     x, y, xRotated, yy.
	        DEFB    $01             ;;exchange      x, y, yy, xRotated.
	        DEFB    $C1             ;;st-mem-1      x, y, yy, xRotated.
	        DEFB    $02             ;;delete        x, y, yy.

	        DEFB    $E0             ;;get-mem-0     x, y, yy, cos(angle).
	        DEFB    $04             ;;multiply      x, y, yy*cos(angle).
	        DEFB    $E2             ;;get-mem-2     x, y, yy*cos(angle), xx.
	        DEFB    $E5             ;;get-mem-5     x, y, yy*cos(angle), xx, sin(angle).
	        DEFB    $04             ;;multiply      x, y, yy*cos(angle), xx*sin(angle).
	        DEFB    $03             ;;subtract      x, y, yRotated.
	        DEFB    $C2             ;;st-mem-2      x, y, yRotated.

	;   Now the initial x and y coordinates are made positive and summed to see
	;   if they measure up to anything significant.

	        DEFB    $2A             ;;abs           x, y, yRotated'.
	        DEFB    $E1             ;;get-mem-1     x, y, yRotated', xRotated.
	        DEFB    $2A             ;;abs           x, y, yRotated', xRotated'.
	        DEFB    $0F             ;;addition      x, y, yRotated+xRotated.
	        DEFB    $02             ;;delete        x, y.

	        DEFB    $38             ;;end-calc      x, y.

	;   Although the test value has been deleted it is still above the calculator
	;   stack in memory and conveniently DE which points to the first free byte
	;   addresses the exponent of the test value.

	        LD      A,(DE)          ; Fetch exponent of the length indicator.
	        CP      $81             ; Compare to that for 1

	        POP     BC              ; Balance the machine stack

	        JP      C,L2477         ; forward, if the coordinates of first line
	                                ; don't add up to more than 1, to LINE-DRAW

	;   Continue when the arc will have a discernable shape.

	        PUSH    BC              ; Restore line counter to the machine stack.

	;   The parameters of the DRAW command were relative and they are now converted
	;   to absolute coordinates by adding to the coordinates of the last point
	;   plotted. The first two values on the stack are the terminal tx and ty
	;   coordinates.  The x-coordinate is converted first but first the last point
	;   plotted is saved as it will initialize the moving ax, value.

	        RST     28H             ;; FP-CALC      x, y.
	        DEFB    $01             ;;exchange      y, x.
	        DEFB    $38             ;;end-calc      y, x.

	        LD      A,(COORDS)      ;; Fetch System Variable COORDS-x
	        CALL    L2D28           ;; routine STACK-A

	        RST     28H             ;; FP-CALC      y, x, last-x.

	;   Store the last point plotted to initialize the moving ax value.

	        DEFB    $C0             ;;st-mem-0      y, x, last-x.
	        DEFB    $0F             ;;addition      y, absolute x.
	        DEFB    $01             ;;exchange      tx, y.
	        DEFB    $38             ;;end-calc      tx, y.

	        LD      A,(COORDS + 1)  ; Fetch System Variable COORDS-y
	        CALL    L2D28           ; routine STACK-A

	        RST     28H             ;; FP-CALC      tx, y, last-y.

	;   Store the last point plotted to initialize the moving ay value.

	        DEFB    $C5             ;;st-mem-5      tx, y, last-y.
	        DEFB    $0F             ;;addition      tx, ty.

	;   Fetch the moving ax and ay to the calculator stack.

	        DEFB    $E0             ;;get-mem-0     tx, ty, ax.
	        DEFB    $E5             ;;get-mem-5     tx, ty, ax, ay.
	        DEFB    $38             ;;end-calc      tx, ty, ax, ay.

	        POP     BC              ; Restore the straight line count.

	; -----------------------------------
	; THE 'CIRCLE/DRAW CONVERGENCE POINT'
	; -----------------------------------
	;   The CIRCLE and ARC-DRAW commands converge here.
	;
	;   Note. for both the CIRCLE and ARC commands the minimum initial line count
	;   is 4 (as set up by the CD_PARAMS routine) and so the zero flag will never
	;   be set and the loop is always entered.  The first test is superfluous and
	;   the jump will always be made to ARC-START.

	;; DRW-STEPS
L2420:  DEC     B               ; decrement the arc count (4,8,12,16...).

	        ;JR      Z,L245F         ; forward, if zero (not possible), to ARC-END

	        JP      L2439           ; forward to ARC-START

	; --------------
	; THE 'ARC LOOP'
	; --------------
	;
	;   The arc drawing loop will draw up to 31 straight lines for a circle and up
	;   251 straight lines for an arc between two points. In both cases the final
	;   closing straight line is drawn at ARC_END, but it otherwise loops back to
	;   here to calculate the next coordinate using the ROTATION FORMULA where (a)
	;   is the previously calculated, constant CENTRAL ANGLE of the arcs.
	;
	;       Xrotated = x * cos(a) - y * sin(a)
	;       Yrotated = x * sin(a) + y * cos(a)
	;
	;   The values cos(a) and sin(a) are pre-calculated and held in mem-3 and mem-4
	;   for the duration of the routine.
	;   Memory location mem-1 holds the last relative x value (rx) and mem-2 holds
	;   the last relative y value (ry) used by DRAW.
	;
	;   Note. that this is a very clever twist on what is after all a very clever,
	;   well-used formula.  Normally the rotation formula is used with the x and y
	;   coordinates from the centre of the circle (or arc) and a supplied angle to
	;   produce two new x and y coordinates in an anticlockwise direction on the
	;   circumference of the circle.
	;   What is being used here, instead, is the relative X and Y parameters from
	;   the last point plotted that are required to get to the current point and
	;   the formula returns the next relative coordinates to use.

	;; ARC-LOOP
L2425:  RST     28H             ;; FP-CALC
	        DEFB    $E1             ;;get-mem-1     rx.
	        DEFB    $31             ;;duplicate     rx, rx.
	        DEFB    $E3             ;;get-mem-3     cos(a)
	        DEFB    $04             ;;multiply      rx, rx*cos(a).
	        DEFB    $E2             ;;get-mem-2     rx, rx*cos(a), ry.
	        DEFB    $E4             ;;get-mem-4     rx, rx*cos(a), ry, sin(a).
	        DEFB    $04             ;;multiply      rx, rx*cos(a), ry*sin(a).
	        DEFB    $03             ;;subtract      rx, rx*cos(a) - ry*sin(a)
	        DEFB    $C1             ;;st-mem-1      rx, new relative x rotated.
	        DEFB    $02             ;;delete        rx.

	        DEFB    $E4             ;;get-mem-4     rx, sin(a).
	        DEFB    $04             ;;multiply      rx*sin(a)
	        DEFB    $E2             ;;get-mem-2     rx*sin(a), ry.
	        DEFB    $E3             ;;get-mem-3     rx*sin(a), ry, cos(a).
	        DEFB    $04             ;;multiply      rx*sin(a), ry*cos(a).
	        DEFB    $0F             ;;addition      rx*sin(a) + ry*cos(a).
	        DEFB    $C2             ;;st-mem-2      new relative y rotated.
	        DEFB    $02             ;;delete        .
	        DEFB    $38             ;;end-calc      .

	;   Note. the calculator stack actually holds   tx, ty, ax, ay
	;   and the last absolute values of x and y
	;   are now brought into play.
	;
	;   Magically, the two new rotated coordinates rx and ry are all that we would
	;   require to draw a circle or arc - on paper!
	;   The Spectrum DRAW routine draws to the rounded x and y coordinate and so
	;   repetitions of values like 3.49 would mean that the fractional parts
	;   would be lost until eventually the draw coordinates might differ from the
	;   floating point values used above by several pixels.
	;   For this reason the accurate offsets calculated above are added to the
	;   accurate, absolute coordinates maintained in ax and ay and these new
	;   coordinates have the integer coordinates of the last plot position
	;   ( from System Variable COORDS ) subtracted from them to give the relative
	;   coordinates required by the DRAW routine.

	;   The mid entry point.

	;; ARC-START
L2439:  PUSH    BC              ; Preserve the arc counter on the machine stack.

	;   Store the absolute ay in temporary variable mem-0 for the moment.

	        RST     28H             ;; FP-CALC      ax, ay.
	        DEFB    $C0             ;;st-mem-0      ax, ay.
	        DEFB    $02             ;;delete        ax.

	;   Now add the fractional relative x coordinate to the fractional absolute
	;   x coordinate to obtain a new fractional x-coordinate.

	        DEFB    $E1             ;;get-mem-1     ax, xr.
	        DEFB    $0F             ;;addition      ax+xr (= new ax).
	        DEFB    $31             ;;duplicate     ax, ax.
	        DEFB    $38             ;;end-calc      ax, ax.

	        LD      A,(COORDS)       ; COORDS-x      last x    (integer ix 0-255)
	        CALL    L2D28           ; routine STACK-A

	        RST     28H             ;; FP-CALC      ax, ax, ix.
	        DEFB    $03             ;;subtract      ax, ax-ix  = relative DRAW Dx.

	;   Having calculated the x value for DRAW do the same for the y value.

	        DEFB    $E0             ;;get-mem-0     ax, Dx, ay.
	        DEFB    $E2             ;;get-mem-2     ax, Dx, ay, ry.
	        DEFB    $0F             ;;addition      ax, Dx, ay+ry (= new ay).
	        DEFB    $C0             ;;st-mem-0      ax, Dx, ay.
	        DEFB    $01             ;;exchange      ax, ay, Dx,
	        DEFB    $E0             ;;get-mem-0     ax, ay, Dx, ay.
	        DEFB    $38             ;;end-calc      ax, ay, Dx, ay.

	        LD      A,(COORDS + 1)  ; COORDS-y      last y (integer iy 0-175)
	        CALL    L2D28           ; routine STACK-A

	        RST     28H             ;; FP-CALC      ax, ay, Dx, ay, iy.
	        DEFB    $03             ;;subtract      ax, ay, Dx, ay-iy ( = Dy).
	        DEFB    $38             ;;end-calc      ax, ay, Dx, Dy.

	        CALL    L2477           ; Routine DRAW-LINE draws (Dx,Dy) relative to
	                                ; the last pixel plotted leaving absolute x
	                                ; and y on the calculator stack.
	                                ;               ax, ay.

	        POP     BC              ; Restore the arc counter from the machine stack.

	        DJNZ    L2425           ; Decrement and loop while > 0 to ARC-LOOP

	; -------------
	; THE 'ARC END'
	; -------------

	;   To recap the full calculator stack is       tx, ty, ax, ay.

	;   Just as one would do if drawing the curve on paper, the final line would
	;   be drawn by joining the last point plotted to the initial start point
	;   in the case of a CIRCLE or to the calculated end point in the case of
	;   an ARC.
	;   The moving absolute values of x and y are no longer required and they
	;   can be deleted to expose the closing coordinates.

	;; ARC-END
L245F:  RST     28H             ;; FP-CALC      tx, ty, ax, ay.
	        DEFB    $02             ;;delete        tx, ty, ax.
	        DEFB    $02             ;;delete        tx, ty.
	        DEFB    $01             ;;exchange      ty, tx.
	        DEFB    $38             ;;end-calc      ty, tx.

	;   First calculate the relative x coordinate to the end-point.

	        LD      A,($5C7D)       ; COORDS-x
	        CALL    L2D28           ; routine STACK-A

	        RST     28H             ;; FP-CALC      ty, tx, coords_x.
	        DEFB    $03             ;;subtract      ty, rx.

	;   Next calculate the relative y coordinate to the end-point.

	        DEFB    $01             ;;exchange      rx, ty.
	        DEFB    $38             ;;end-calc      rx, ty.

	        LD      A,($5C7E)       ; COORDS-y
	        CALL    L2D28           ; routine STACK-A

	        RST     28H             ;; FP-CALC      rx, ty, coords_y
	        DEFB    $03             ;;subtract      rx, ry.
	        DEFB    $38             ;;end-calc      rx, ry.
	;   Finally draw the last straight line.
L2477:
	        call    STACK_TO_BC     ;;Pops x, and y, and stores it in B, C
	        ld      hl, (COORDS)    ;;Calculates x2 and y2 in L, H

	        rl      e               ;; Rotate left to carry
	        ld      a, c
	        jr      nc, SUM_C
	        neg
SUM_C:
	        add     a, l
	        ld      l, a            ;; X2

	        rl      d               ;; Low sign to carry
	        ld      a, b
	        jr      nc, SUM_B
	        neg
SUM_B:
	        add     a, h
	        ld      h, a
	        jp      __DRAW          ;;forward to LINE-DRAW (Fastcalled)

	        ENDP
#line 870 "VecttyRenderer.zxbas"
#line 1 "lti16.asm"

#line 1 "lei8.asm"

__LEI8: ; Signed <= comparison for 8bit int
	        ; A <= H (registers)
	    PROC
	    LOCAL checkParity
	    sub h
	    jr nz, __LTI
	    inc a
	    ret

__LTI8:  ; Test 8 bit values A < H
	    sub h

__LTI:   ; Generic signed comparison
	    jp po, checkParity
	    xor 0x80
checkParity:
	    ld a, 0     ; False
	    ret p
	    inc a       ; True
	    ret
	    ENDP
#line 2 "lti16.asm"

__LTI16: ; Test 8 bit values HL < DE
         ; Returns result in A: 0 = False, !0 = True
	    PROC
	    LOCAL checkParity
	    or a
	    sbc hl, de
	    jp po, checkParity
	    ld a, h
	    xor 0x80
checkParity:
	    ld a, 0     ; False
	    ret p
	    inc a       ; True
	    ret
	    ENDP
#line 871 "VecttyRenderer.zxbas"
#line 1 "mulf.asm"



	; -------------------------------------------------------------
	; Floating point library using the FP ROM Calculator (ZX 48K)
	; All of them uses A EDCB registers as 1st paramter.
	; For binary operators, the 2n operator must be pushed into the
	; stack, in the order A DE BC.
	;
	; Uses CALLEE convention
	; -------------------------------------------------------------

__MULF:	; Multiplication
		call __FPSTACK_PUSH2

		; ------------- ROM MUL
		rst 28h
		defb 04h	;
		defb 38h;   ; END CALC

		jp __FPSTACK_POP

#line 872 "VecttyRenderer.zxbas"
#line 1 "ploadf.asm"

	; Parameter / Local var load
	; A => Offset
	; IX = Stack Frame
; RESULT: HL => IX + DE

#line 1 "iloadf.asm"

	; __FASTCALL__ routine which
	; loads a 40 bits floating point into A ED CB
	; stored at position pointed by POINTER HL
	;A DE, BC <-- ((HL))

__ILOADF:
	    ld a, (hl)
	    inc hl
	    ld h, (hl)
	    ld l, a

	; __FASTCALL__ routine which
	; loads a 40 bits floating point into A ED CB
	; stored at position pointed by POINTER HL
	;A DE, BC <-- (HL)

__LOADF:    ; Loads a 40 bits FP number from address pointed by HL
		ld a, (hl)
		inc hl
		ld e, (hl)
		inc hl
		ld d, (hl)
		inc hl
		ld c, (hl)
		inc hl
		ld b, (hl)
		ret

#line 7 "ploadf.asm"

__PLOADF:
	    push ix
	    pop hl
	    add hl, de
	    jp __LOADF

#line 873 "VecttyRenderer.zxbas"

#line 1 "print.asm"

; vim:ts=4:sw=4:et:
	; PRINT command routine
	; Does not print attribute. Use PRINT_STR or PRINT_NUM for that




#line 1 "table_jump.asm"


JUMP_HL_PLUS_2A: ; Does JP (HL + A*2) Modifies DE. Modifies A
		add a, a

JUMP_HL_PLUS_A:	 ; Does JP (HL + A) Modifies DE
		ld e, a
		ld d, 0

JUMP_HL_PLUS_DE: ; Does JP (HL + DE)
		add hl, de
		ld e, (hl)
		inc hl
		ld d, (hl)
		ex de, hl
CALL_HL:
		jp (hl)

#line 9 "print.asm"
#line 1 "ink.asm"

	; Sets ink color in ATTR_P permanently
; Parameter: Paper color in A register



INK:
		PROC
		LOCAL __SET_INK
		LOCAL __SET_INK2

		ld de, ATTR_P

__SET_INK:
		cp 8
		jr nz, __SET_INK2

		inc de ; Points DE to MASK_T or MASK_P
		ld a, (de)
		or 7 ; Set bits 0,1,2 to enable transparency
		ld (de), a
		ret

__SET_INK2:
		; Another entry. This will set the ink color at location pointer by DE
		and 7	; # Gets color mod 8
		ld b, a	; Saves the color
		ld a, (de)
		and 0F8h ; Clears previous value
		or b
		ld (de), a
		inc de ; Points DE to MASK_T or MASK_P
		ld a, (de)
		and 0F8h ; Reset bits 0,1,2 sign to disable transparency
		ld (de), a ; Store new attr
		ret

	; Sets the INK color passed in A register in the ATTR_T variable
INK_TMP:
		ld de, ATTR_T
		jp __SET_INK

		ENDP

#line 10 "print.asm"
#line 1 "paper.asm"

	; Sets paper color in ATTR_P permanently
; Parameter: Paper color in A register



PAPER:
		PROC
		LOCAL __SET_PAPER
		LOCAL __SET_PAPER2

		ld de, ATTR_P

__SET_PAPER:
		cp 8
		jr nz, __SET_PAPER2
		inc de
		ld a, (de)
		or 038h
		ld (de), a
		ret

		; Another entry. This will set the paper color at location pointer by DE
__SET_PAPER2:
		and 7	; # Remove
		rlca
		rlca
		rlca		; a *= 8

		ld b, a	; Saves the color
		ld a, (de)
		and 0C7h ; Clears previous value
		or b
		ld (de), a
		inc de ; Points to MASK_T or MASK_P accordingly
		ld a, (de)
		and 0C7h  ; Resets bits 3,4,5
		ld (de), a
		ret


	; Sets the PAPER color passed in A register in the ATTR_T variable
PAPER_TMP:
		ld de, ATTR_T
		jp __SET_PAPER
		ENDP

#line 11 "print.asm"
#line 1 "flash.asm"

	; Sets flash flag in ATTR_P permanently
; Parameter: Paper color in A register



FLASH:
		ld hl, ATTR_P

	    PROC
	    LOCAL IS_TR
	    LOCAL IS_ZERO

__SET_FLASH:
		; Another entry. This will set the flash flag at location pointer by DE
		cp 8
		jr z, IS_TR

		; # Convert to 0/1
		or a
		jr z, IS_ZERO
		ld a, 0x80

IS_ZERO:
		ld b, a	; Saves the color
		ld a, (hl)
		and 07Fh ; Clears previous value
		or b
		ld (hl), a
		inc hl
		res 7, (hl)  ;Reset bit 7 to disable transparency
		ret

IS_TR:  ; transparent
		inc hl ; Points DE to MASK_T or MASK_P
		set 7, (hl)  ;Set bit 7 to enable transparency
		ret

	; Sets the FLASH flag passed in A register in the ATTR_T variable
FLASH_TMP:
		ld hl, ATTR_T
		jr __SET_FLASH
	    ENDP

#line 12 "print.asm"
#line 1 "bright.asm"

	; Sets bright flag in ATTR_P permanently
; Parameter: Paper color in A register



BRIGHT:
		ld hl, ATTR_P

	    PROC
	    LOCAL IS_TR
	    LOCAL IS_ZERO

__SET_BRIGHT:
		; Another entry. This will set the bright flag at location pointer by DE
		cp 8
		jr z, IS_TR

		; # Convert to 0/1
		or a
		jr z, IS_ZERO
		ld a, 0x40

IS_ZERO:
		ld b, a	; Saves the color
		ld a, (hl)
		and 0BFh ; Clears previous value
		or b
		ld (hl), a
		inc hl
		res 6, (hl)  ;Reset bit 6 to disable transparency
		ret

IS_TR:  ; transparent
		inc hl ; Points DE to MASK_T or MASK_P
	    set 6, (hl)  ;Set bit 6 to enable transparency
		ret

	; Sets the BRIGHT flag passed in A register in the ATTR_T variable
BRIGHT_TMP:
		ld hl, ATTR_T
		jr __SET_BRIGHT
	    ENDP
#line 13 "print.asm"
#line 1 "over.asm"

	; Sets OVER flag in P_FLAG permanently
; Parameter: OVER flag in bit 0 of A register
#line 1 "copy_attr.asm"



#line 4 "C:/ZXBasic/library-asm/copy_attr.asm"



COPY_ATTR:
		; Just copies current permanent attribs to temporal attribs
		; and sets print mode
		PROC

		LOCAL INVERSE1
		LOCAL __REFRESH_TMP

	INVERSE1 EQU 02Fh

		ld hl, (ATTR_P)
		ld (ATTR_T), hl

		ld hl, FLAGS2
		call __REFRESH_TMP

		ld hl, P_FLAG
		call __REFRESH_TMP


__SET_ATTR_MODE:		; Another entry to set print modes. A contains (P_FLAG)


		LOCAL TABLE
		LOCAL CONT2

		rra					; Over bit to carry
		ld a, (FLAGS2)
		rla					; Over bit in bit 1, Over2 bit in bit 2
		and 3				; Only bit 0 and 1 (OVER flag)

		ld c, a
		ld b, 0

		ld hl, TABLE
		add hl, bc
		ld a, (hl)
		ld (PRINT_MODE), a

		ld hl, (P_FLAG)
		xor a			; NOP -> INVERSE0
		bit 2, l
		jr z, CONT2
		ld a, INVERSE1 	; CPL -> INVERSE1

CONT2:
		ld (INVERSE_MODE), a
		ret

TABLE:
		nop				; NORMAL MODE
		xor (hl)		; OVER 1 MODE
		and (hl)		; OVER 2 MODE
		or  (hl)		; OVER 3 MODE

#line 65 "C:/ZXBasic/library-asm/copy_attr.asm"

__REFRESH_TMP:
		ld a, (hl)
		and 10101010b
		ld c, a
		rra
		or c
		ld (hl), a
		ret

		ENDP

#line 4 "over.asm"


OVER:
		PROC

		ld c, a ; saves it for later
		and 2
		ld hl, FLAGS2
		res 1, (HL)
		or (hl)
		ld (hl), a

		ld a, c	; Recovers previous value
		and 1	; # Convert to 0/1
		add a, a; # Shift left 1 bit for permanent

		ld hl, P_FLAG
		res 1, (hl)
		or (hl)
		ld (hl), a
		ret

	; Sets OVER flag in P_FLAG temporarily
OVER_TMP:
		ld c, a ; saves it for later
		and 2	; gets bit 1; clears carry
		rra
		ld hl, FLAGS2
		res 0, (hl)
		or (hl)
		ld (hl), a

		ld a, c	; Recovers previous value
		and 1
		ld hl, P_FLAG
		res 0, (hl)
	    or (hl)
		ld (hl), a
		jp __SET_ATTR_MODE

		ENDP

#line 14 "print.asm"
#line 1 "inverse.asm"

	; Sets INVERSE flag in P_FLAG permanently
; Parameter: INVERSE flag in bit 0 of A register



INVERSE:
		PROC

		and 1	; # Convert to 0/1
		add a, a; # Shift left 3 bits for permanent
		add a, a
		add a, a
		ld hl, P_FLAG
		res 3, (hl)
		or (hl)
		ld (hl), a
		ret

	; Sets INVERSE flag in P_FLAG temporarily
INVERSE_TMP:
		and 1
		add a, a
		add a, a; # Shift left 2 bits for temporary
		ld hl, P_FLAG
		res 2, (hl)
		or (hl)
		ld (hl), a
		jp __SET_ATTR_MODE

		ENDP

#line 15 "print.asm"
#line 1 "bold.asm"

	; Sets BOLD flag in P_FLAG permanently
; Parameter: BOLD flag in bit 0 of A register


BOLD:
		PROC

		and 1
		rlca
	    rlca
	    rlca
		ld hl, FLAGS2
		res 3, (HL)
		or (hl)
		ld (hl), a
		ret

	; Sets BOLD flag in P_FLAG temporarily
BOLD_TMP:
		and 1
		rlca
		rlca
		ld hl, FLAGS2
		res 2, (hl)
		or (hl)
		ld (hl), a
		ret

		ENDP

#line 16 "print.asm"
#line 1 "italic.asm"

	; Sets ITALIC flag in P_FLAG permanently
; Parameter: ITALIC flag in bit 0 of A register


ITALIC:
		PROC

		and 1
	    rrca
	    rrca
	    rrca
		ld hl, FLAGS2
		res 5, (HL)
		or (hl)
		ld (hl), a
		ret

	; Sets ITALIC flag in P_FLAG temporarily
ITALIC_TMP:
		and 1
		rrca
		rrca
		rrca
		rrca
		ld hl, FLAGS2
		res 4, (hl)
		or (hl)
		ld (hl), a
		ret

		ENDP

#line 17 "print.asm"



	; Putting a comment starting with @INIT <address>
	; will make the compiler to add a CALL to <address>
	; It is useful for initialization routines.


__PRINT_INIT: ; To be called before program starts (initializes library)
	        PROC

	        ld hl, __PRINT_START
	        ld (PRINT_JUMP_STATE), hl

	        ld hl, 1821h
	        ld (MAXX), hl  ; Sets current maxX and maxY

	        xor a
	        ld (FLAGS2), a

	        ret


__PRINTCHAR: ; Print character store in accumulator (A register)
	             ; Modifies H'L', B'C', A'F', D'E', A

	        LOCAL PO_GR_1

	        LOCAL __PRCHAR
	        LOCAL __PRINT_CONT
	        LOCAL __PRINT_CONT2
	        LOCAL __PRINT_JUMP
	        LOCAL __SRCADDR
	        LOCAL __PRINT_UDG
	        LOCAL __PRGRAPH
	        LOCAL __PRINT_START
	        LOCAL __ROM_SCROLL_SCR
	        LOCAL __TVFLAGS

	        __ROM_SCROLL_SCR EQU 0DFEh
	        __TVFLAGS EQU 5C3Ch

	PRINT_JUMP_STATE EQU __PRINT_JUMP + 1

__PRINT_JUMP:
	        jp __PRINT_START    ; Where to jump. If we print 22 (AT), next two calls jumps to AT1 and AT2 respectively


	        LOCAL __SCROLL
__SCROLL:  ; Scroll?
	        ld hl, __TVFLAGS
	        bit 1, (hl)
	        ret z
	        call __ROM_SCROLL_SCR
	        ld hl, __TVFLAGS
	        res 1, (hl)
	        ret
#line 75 "C:/ZXBasic/library-asm/print.asm"

__PRINT_START:
	        cp ' '
	        jp c, __PRINT_SPECIAL    ; Characters below ' ' are special ones

	        exx               ; Switch to alternative registers
	        ex af, af'        ; Saves a value (char to print) for later


	        call __SCROLL
#line 86 "C:/ZXBasic/library-asm/print.asm"
	        call __LOAD_S_POSN

	; At this point we have the new coord
	        ld hl, (SCREEN_ADDR)

	        ld a, d
	        ld c, a     ; Saves it for later

	        and 0F8h    ; Masks 3 lower bit ; zy
	        ld d, a

	        ld a, c     ; Recovers it
	        and 07h     ; MOD 7 ; y1
	        rrca
	        rrca
	        rrca

	        or e
	        ld e, a
	        add hl, de    ; HL = Screen address + DE
	        ex de, hl     ; DE = Screen address

	        ex af, af'

	        cp 80h    ; Is it an UDG or a ?
	        jp c, __SRCADDR

	        cp 90h
	        jp nc, __PRINT_UDG

	        ; Print a 8 bit pattern (80h to 8Fh)

	        ld b, a
	        call PO_GR_1 ; This ROM routine will generate the bit pattern at MEM0
	        ld hl, MEM0
	        jp __PRGRAPH

	PO_GR_1 EQU 0B38h

__PRINT_UDG:
	        sub 90h ; Sub ASC code
	        ld bc, (UDG)
	        jp __PRGRAPH0

	__SOURCEADDR EQU (__SRCADDR + 1)    ; Address of the pointer to chars source
__SRCADDR:
	        ld bc, (CHARS)

__PRGRAPH0:
        add a, a   ; A = a * 2 (since a < 80h) ; Thanks to Metalbrain at http://foro.speccy.org
	        ld l, a
	        ld h, 0    ; HL = a * 2 (accumulator)
	        add hl, hl
	        add hl, hl ; HL = a * 8
	        add hl, bc ; HL = CHARS address

__PRGRAPH:
	        ex de, hl  ; HL = Write Address, DE = CHARS address
	        bit 2, (iy + $47)
	        call nz, __BOLD
	        bit 4, (iy + $47)
	        call nz, __ITALIC
	        ld b, 8 ; 8 bytes per char
__PRCHAR:
	        ld a, (de) ; DE *must* be ALWAYS source, and HL destiny

PRINT_MODE:     ; Which operation is used to write on the screen
                ; Set it with:
	                ; LD A, <OPERATION>
	                ; LD (PRINT_MODE), A
	                ;
                ; Available opertions:
                ; NORMAL : 0h  --> NOP         ; OVER 0
                ; XOR    : AEh --> XOR (HL)    ; OVER 1
                ; OR     : B6h --> OR (HL)     ; PUTSPRITE
                ; AND    : A6h --> AND (HL)    ; PUTMASK
	        nop     ;

INVERSE_MODE:   ; 00 -> NOP -> INVERSE 0
	        nop     ; 2F -> CPL -> INVERSE 1

	        ld (hl), a

	        inc de
	        inc h     ; Next line
	        djnz __PRCHAR

	        call __LOAD_S_POSN
	        push de
	        call __SET_ATTR
	        pop de
	        inc e            ; COL = COL + 1
	        ld hl, (MAXX)
	        ld a, e
	        dec l            ; l = MAXX
	        cp l            ; Lower than max?
	        jp c, __PRINT_CONT; Nothing to do
	        call __PRINT_EOL1
	        exx            ; counteracts __PRINT_EOL1 exx
	        jp __PRINT_CONT2

__PRINT_CONT:
	        call __SAVE_S_POSN

__PRINT_CONT2:
	        exx
	        ret

	; ------------- SPECIAL CHARS (< 32) -----------------

__PRINT_SPECIAL:    ; Jumps here if it is a special char
	        exx
	        ld hl, __PRINT_TABLE
	        jp JUMP_HL_PLUS_2A


PRINT_EOL:        ; Called WHENEVER there is no ";" at end of PRINT sentence
	        exx

__PRINT_0Dh:        ; Called WHEN printing CHR$(13)

	        call __SCROLL
#line 209 "C:/ZXBasic/library-asm/print.asm"
	        call __LOAD_S_POSN

__PRINT_EOL1:        ; Another entry called from PRINT when next line required
	        ld e, 0

__PRINT_EOL2:
	        ld a, d
	        inc a

__PRINT_AT1_END:
	        ld hl, (MAXY)
	        cp l
	        jr c, __PRINT_EOL_END    ; Carry if (MAXY) < d
	        ld hl, __TVFLAGS
	        set 1, (hl)
	        ld a, d

__PRINT_EOL_END:
	        ld d, a

__PRINT_AT2_END:
	        call __SAVE_S_POSN
	        exx
	        ret

__PRINT_COM:
	        exx
	        push hl
	        push de
	        push bc
	        call PRINT_COMMA
	        pop bc
	        pop de
	        pop hl
	        ret

__PRINT_TAB:
	        ld hl, __PRINT_TAB1
	        jp __PRINT_SET_STATE

__PRINT_TAB1:
	        ld (MEM0), a
	        ld hl, __PRINT_TAB2
	        ld (PRINT_JUMP_STATE), hl
	        ret

__PRINT_TAB2:
	        ld a, (MEM0)        ; Load tab code (ignore the current one)
	        push hl
	        push de
	        push bc
	        ld hl, __PRINT_START
	        ld (PRINT_JUMP_STATE), hl
	        call PRINT_TAB
	        pop bc
	        pop de
	        pop hl
	        ret

__PRINT_NOP:
__PRINT_RESTART:
	        ld hl, __PRINT_START
	        jp __PRINT_SET_STATE

__PRINT_AT:
	        ld hl, __PRINT_AT1

__PRINT_SET_STATE:
	        ld (PRINT_JUMP_STATE), hl    ; Saves next entry call
	        exx
	        ret

__PRINT_AT1:    ; Jumps here if waiting for 1st parameter
	        exx
	        ld hl, __PRINT_AT2
	        ld (PRINT_JUMP_STATE), hl    ; Saves next entry call
	        call __LOAD_S_POSN
	        jp __PRINT_AT1_END

__PRINT_AT2:
	        exx
	        ld hl, __PRINT_START
	        ld (PRINT_JUMP_STATE), hl    ; Saves next entry call
	        call __LOAD_S_POSN
	        ld e, a
	        ld hl, (MAXX)
	        cp (hl)
	        jr c, __PRINT_AT2_END
	        jr __PRINT_EOL1

__PRINT_DEL:
	        call __LOAD_S_POSN        ; Gets current screen position
	        dec e
	        ld a, -1
	        cp e
	        jp nz, __PRINT_AT2_END
	        ld hl, (MAXX)
	        ld e, l
	        dec e
	        dec e
	        dec d
	        cp d
	        jp nz, __PRINT_AT2_END
	        ld d, h
	        dec d
	        jp __PRINT_AT2_END

__PRINT_INK:
	        ld hl, __PRINT_INK2
	        jp __PRINT_SET_STATE

__PRINT_INK2:
	        exx
	        call INK_TMP
	        jp __PRINT_RESTART

__PRINT_PAP:
	        ld hl, __PRINT_PAP2
	        jp __PRINT_SET_STATE

__PRINT_PAP2:
	        exx
	        call PAPER_TMP
	        jp __PRINT_RESTART

__PRINT_FLA:
	        ld hl, __PRINT_FLA2
	        jp __PRINT_SET_STATE

__PRINT_FLA2:
	        exx
	        call FLASH_TMP
	        jp __PRINT_RESTART

__PRINT_BRI:
	        ld hl, __PRINT_BRI2
	        jp __PRINT_SET_STATE

__PRINT_BRI2:
	        exx
	        call BRIGHT_TMP
	        jp __PRINT_RESTART

__PRINT_INV:
	        ld hl, __PRINT_INV2
	        jp __PRINT_SET_STATE

__PRINT_INV2:
	        exx
	        call INVERSE_TMP
	        jp __PRINT_RESTART

__PRINT_OVR:
	        ld hl, __PRINT_OVR2
	        jp __PRINT_SET_STATE

__PRINT_OVR2:
	        exx
	        call OVER_TMP
	        jp __PRINT_RESTART

__PRINT_BOLD:
	        ld hl, __PRINT_BOLD2
	        jp __PRINT_SET_STATE

__PRINT_BOLD2:
	        exx
	        call BOLD_TMP
	        jp __PRINT_RESTART

__PRINT_ITA:
	        ld hl, __PRINT_ITA2
	        jp __PRINT_SET_STATE

__PRINT_ITA2:
	        exx
	        call ITALIC_TMP
	        jp __PRINT_RESTART


__BOLD:
	        push hl
	        ld hl, MEM0
	        ld b, 8
__BOLD_LOOP:
	        ld a, (de)
	        ld c, a
	        rlca
	        or c
	        ld (hl), a
	        inc hl
	        inc de
	        djnz __BOLD_LOOP
	        pop hl
	        ld de, MEM0
	        ret


__ITALIC:
	        push hl
	        ld hl, MEM0
	        ex de, hl
	        ld bc, 8
	        ldir
	        ld hl, MEM0
	        srl (hl)
	        inc hl
	        srl (hl)
	        inc hl
	        srl (hl)
	        inc hl
	        inc hl
	        inc hl
	        sla (hl)
	        inc hl
	        sla (hl)
	        inc hl
	        sla (hl)
	        pop hl
	        ld de, MEM0
	        ret

PRINT_COMMA:
	        call __LOAD_S_POSN
	        ld a, e
	        and 16
	        add a, 16

PRINT_TAB:
	        PROC
	        LOCAL LOOP, CONTINUE

	        inc a
	        call __LOAD_S_POSN ; e = current row
	        ld d, a
	        ld a, e
	        cp 21h
	        jr nz, CONTINUE
	        ld e, -1
CONTINUE:
	        ld a, d
	        inc e
	        sub e  ; A = A - E
	        and 31 ;
	        ret z  ; Already at position E
	        ld b, a
LOOP:
	        ld a, ' '
	        call __PRINTCHAR
	        djnz LOOP
	        ret
	        ENDP

PRINT_AT: ; Changes cursor to ROW, COL
	         ; COL in A register
	         ; ROW in stack

	        pop hl    ; Ret address
	        ex (sp), hl ; callee H = ROW
	        ld l, a
	        ex de, hl

	        call __IN_SCREEN
	        ret nc    ; Return if out of screen
	        ld hl, __TVFLAGS
	        res 1, (hl)
	        jp __SAVE_S_POSN

	        LOCAL __PRINT_COM
	        LOCAL __BOLD
	        LOCAL __BOLD_LOOP
	        LOCAL __ITALIC
	        LOCAL __PRINT_EOL1
	        LOCAL __PRINT_EOL2
	        LOCAL __PRINT_AT1
	        LOCAL __PRINT_AT2
	        LOCAL __PRINT_AT2_END
	        LOCAL __PRINT_BOLD
	        LOCAL __PRINT_BOLD2
	        LOCAL __PRINT_ITA
	        LOCAL __PRINT_ITA2
	        LOCAL __PRINT_INK
	        LOCAL __PRINT_PAP
	        LOCAL __PRINT_SET_STATE
	        LOCAL __PRINT_TABLE
	        LOCAL __PRINT_TAB, __PRINT_TAB1, __PRINT_TAB2

__PRINT_TABLE:    ; Jump table for 0 .. 22 codes

	        DW __PRINT_NOP    ;  0
	        DW __PRINT_NOP    ;  1
	        DW __PRINT_NOP    ;  2
	        DW __PRINT_NOP    ;  3
	        DW __PRINT_NOP    ;  4
	        DW __PRINT_NOP    ;  5
	        DW __PRINT_COM    ;  6 COMMA
	        DW __PRINT_NOP    ;  7
	        DW __PRINT_DEL    ;  8 DEL
	        DW __PRINT_NOP    ;  9
	        DW __PRINT_NOP    ; 10
	        DW __PRINT_NOP    ; 11
	        DW __PRINT_NOP    ; 12
	        DW __PRINT_0Dh    ; 13
	        DW __PRINT_BOLD   ; 14
	        DW __PRINT_ITA    ; 15
	        DW __PRINT_INK    ; 16
	        DW __PRINT_PAP    ; 17
	        DW __PRINT_FLA    ; 18
	        DW __PRINT_BRI    ; 19
	        DW __PRINT_INV    ; 20
	        DW __PRINT_OVR    ; 21
	        DW __PRINT_AT     ; 22 AT
	        DW __PRINT_TAB    ; 23 TAB

	        ENDP


#line 875 "VecttyRenderer.zxbas"
#line 1 "printstr.asm"




#line 1 "free.asm"

; vim: ts=4:et:sw=4:
	; Copyleft (K) by Jose M. Rodriguez de la Rosa
	;  (a.k.a. Boriel)
;  http://www.boriel.com
	;
	; This ASM library is licensed under the BSD license
	; you can use it for any purpose (even for commercial
	; closed source programs).
	;
	; Please read the BSD license on the internet

	; ----- IMPLEMENTATION NOTES ------
	; The heap is implemented as a linked list of free blocks.

; Each free block contains this info:
	;
	; +----------------+ <-- HEAP START
	; | Size (2 bytes) |
	; |        0       | <-- Size = 0 => DUMMY HEADER BLOCK
	; +----------------+
	; | Next (2 bytes) |---+
	; +----------------+ <-+
	; | Size (2 bytes) |
	; +----------------+
	; | Next (2 bytes) |---+
	; +----------------+   |
	; | <free bytes...>|   | <-- If Size > 4, then this contains (size - 4) bytes
	; | (0 if Size = 4)|   |
	; +----------------+ <-+
	; | Size (2 bytes) |
	; +----------------+
	; | Next (2 bytes) |---+
	; +----------------+   |
	; | <free bytes...>|   |
	; | (0 if Size = 4)|   |
	; +----------------+   |
	;   <Allocated>        | <-- This zone is in use (Already allocated)
	; +----------------+ <-+
	; | Size (2 bytes) |
	; +----------------+
	; | Next (2 bytes) |---+
	; +----------------+   |
	; | <free bytes...>|   |
	; | (0 if Size = 4)|   |
	; +----------------+ <-+
	; | Next (2 bytes) |--> NULL => END OF LIST
	; |    0 = NULL    |
	; +----------------+
	; | <free bytes...>|
	; | (0 if Size = 4)|
	; +----------------+


	; When a block is FREED, the previous and next pointers are examined to see
	; if we can defragment the heap. If the block to be breed is just next to the
	; previous, or to the next (or both) they will be converted into a single
	; block (so defragmented).


	;   MEMORY MANAGER
	;
	; This library must be initialized calling __MEM_INIT with
	; HL = BLOCK Start & DE = Length.

	; An init directive is useful for initialization routines.
	; They will be added automatically if needed.

#line 1 "heapinit.asm"

; vim: ts=4:et:sw=4:
	; Copyleft (K) by Jose M. Rodriguez de la Rosa
	;  (a.k.a. Boriel)
;  http://www.boriel.com
	;
	; This ASM library is licensed under the BSD license
	; you can use it for any purpose (even for commercial
	; closed source programs).
	;
	; Please read the BSD license on the internet

	; ----- IMPLEMENTATION NOTES ------
	; The heap is implemented as a linked list of free blocks.

; Each free block contains this info:
	;
	; +----------------+ <-- HEAP START
	; | Size (2 bytes) |
	; |        0       | <-- Size = 0 => DUMMY HEADER BLOCK
	; +----------------+
	; | Next (2 bytes) |---+
	; +----------------+ <-+
	; | Size (2 bytes) |
	; +----------------+
	; | Next (2 bytes) |---+
	; +----------------+   |
	; | <free bytes...>|   | <-- If Size > 4, then this contains (size - 4) bytes
	; | (0 if Size = 4)|   |
	; +----------------+ <-+
	; | Size (2 bytes) |
	; +----------------+
	; | Next (2 bytes) |---+
	; +----------------+   |
	; | <free bytes...>|   |
	; | (0 if Size = 4)|   |
	; +----------------+   |
	;   <Allocated>        | <-- This zone is in use (Already allocated)
	; +----------------+ <-+
	; | Size (2 bytes) |
	; +----------------+
	; | Next (2 bytes) |---+
	; +----------------+   |
	; | <free bytes...>|   |
	; | (0 if Size = 4)|   |
	; +----------------+ <-+
	; | Next (2 bytes) |--> NULL => END OF LIST
	; |    0 = NULL    |
	; +----------------+
	; | <free bytes...>|
	; | (0 if Size = 4)|
	; +----------------+


	; When a block is FREED, the previous and next pointers are examined to see
	; if we can defragment the heap. If the block to be breed is just next to the
	; previous, or to the next (or both) they will be converted into a single
	; block (so defragmented).


	;   MEMORY MANAGER
	;
	; This library must be initialized calling __MEM_INIT with
	; HL = BLOCK Start & DE = Length.

	; An init directive is useful for initialization routines.
	; They will be added automatically if needed.




	; ---------------------------------------------------------------------
	;  __MEM_INIT must be called to initalize this library with the
	; standard parameters
	; ---------------------------------------------------------------------
__MEM_INIT: ; Initializes the library using (RAMTOP) as start, and
	        ld hl, ZXBASIC_MEM_HEAP  ; Change this with other address of heap start
	        ld de, ZXBASIC_HEAP_SIZE ; Change this with your size

	; ---------------------------------------------------------------------
	;  __MEM_INIT2 initalizes this library
; Parameters:
;   HL : Memory address of 1st byte of the memory heap
;   DE : Length in bytes of the Memory Heap
	; ---------------------------------------------------------------------
__MEM_INIT2:
	        ; HL as TOP
	        PROC

	        dec de
	        dec de
	        dec de
	        dec de        ; DE = length - 4; HL = start
	        ; This is done, because we require 4 bytes for the empty dummy-header block

	        xor a
	        ld (hl), a
	        inc hl
        ld (hl), a ; First "free" block is a header: size=0, Pointer=&(Block) + 4
	        inc hl

	        ld b, h
	        ld c, l
	        inc bc
	        inc bc      ; BC = starts of next block

	        ld (hl), c
	        inc hl
	        ld (hl), b
	        inc hl      ; Pointer to next block

	        ld (hl), e
	        inc hl
	        ld (hl), d
	        inc hl      ; Block size (should be length - 4 at start); This block contains all the available memory

	        ld (hl), a ; NULL (0000h) ; No more blocks (a list with a single block)
	        inc hl
	        ld (hl), a

	        ld a, 201
	        ld (__MEM_INIT), a; "Pokes" with a RET so ensure this routine is not called again
	        ret

	        ENDP

#line 69 "free.asm"

	; ---------------------------------------------------------------------
	; MEM_FREE
	;  Frees a block of memory
	;
; Parameters:
	;  HL = Pointer to the block to be freed. If HL is NULL (0) nothing
	;  is done
	; ---------------------------------------------------------------------

MEM_FREE:
__MEM_FREE: ; Frees the block pointed by HL
	            ; HL DE BC & AF modified
	        PROC

	        LOCAL __MEM_LOOP2
	        LOCAL __MEM_LINK_PREV
	        LOCAL __MEM_JOIN_TEST
	        LOCAL __MEM_BLOCK_JOIN

	        ld a, h
	        or l
	        ret z       ; Return if NULL pointer

	        dec hl
	        dec hl
	        ld b, h
	        ld c, l    ; BC = Block pointer

	        ld hl, ZXBASIC_MEM_HEAP  ; This label point to the heap start

__MEM_LOOP2:
	        inc hl
	        inc hl     ; Next block ptr

	        ld e, (hl)
	        inc hl
	        ld d, (hl) ; Block next ptr
	        ex de, hl  ; DE = &(block->next); HL = block->next

	        ld a, h    ; HL == NULL?
	        or l
	        jp z, __MEM_LINK_PREV; if so, link with previous

	        or a       ; Clear carry flag
	        sbc hl, bc ; Carry if BC > HL => This block if before
	        add hl, bc ; Restores HL, preserving Carry flag
	        jp c, __MEM_LOOP2 ; This block is before. Keep searching PASS the block

	;------ At this point current HL is PAST BC, so we must link (DE) with BC, and HL in BC->next

__MEM_LINK_PREV:    ; Link (DE) with BC, and BC->next with HL
	        ex de, hl
	        push hl
	        dec hl

	        ld (hl), c
	        inc hl
	        ld (hl), b ; (DE) <- BC

	        ld h, b    ; HL <- BC (Free block ptr)
	        ld l, c
	        inc hl     ; Skip block length (2 bytes)
	        inc hl
	        ld (hl), e ; Block->next = DE
	        inc hl
	        ld (hl), d
	        ; --- LINKED ; HL = &(BC->next) + 2

	        call __MEM_JOIN_TEST
	        pop hl

__MEM_JOIN_TEST:   ; Checks for fragmented contiguous blocks and joins them
	                   ; hl = Ptr to current block + 2
	        ld d, (hl)
	        dec hl
	        ld e, (hl)
	        dec hl
	        ld b, (hl) ; Loads block length into BC
	        dec hl
	        ld c, (hl) ;

	        push hl    ; Saves it for later
	        add hl, bc ; Adds its length. If HL == DE now, it must be joined
	        or a
	        sbc hl, de ; If Z, then HL == DE => We must join
	        pop hl
	        ret nz

__MEM_BLOCK_JOIN:  ; Joins current block (pointed by HL) with next one (pointed by DE). HL->length already in BC
	        push hl    ; Saves it for later
	        ex de, hl

	        ld e, (hl) ; DE -> block->next->length
	        inc hl
	        ld d, (hl)
	        inc hl

	        ex de, hl  ; DE = &(block->next)
	        add hl, bc ; HL = Total Length

	        ld b, h
	        ld c, l    ; BC = Total Length

	        ex de, hl
	        ld e, (hl)
	        inc hl
	        ld d, (hl) ; DE = block->next

	        pop hl     ; Recovers Pointer to block
	        ld (hl), c
	        inc hl
	        ld (hl), b ; Length Saved
	        inc hl
	        ld (hl), e
	        inc hl
	        ld (hl), d ; Next saved
	        ret

	        ENDP

#line 5 "printstr.asm"

	; PRINT command routine
	; Prints string pointed by HL

PRINT_STR:
__PRINTSTR:		; __FASTCALL__ Entry to print_string
			PROC
			LOCAL __PRINT_STR_LOOP
	        LOCAL __PRINT_STR_END

	        ld d, a ; Saves A reg (Flag) for later

			ld a, h
			or l
			ret z	; Return if the pointer is NULL

	        push hl

			ld c, (hl)
			inc hl
			ld b, (hl)
			inc hl	; BC = LEN(a$); HL = &a$

__PRINT_STR_LOOP:
			ld a, b
			or c
			jr z, __PRINT_STR_END 	; END if BC (counter = 0)

			ld a, (hl)
			call __PRINTCHAR
			inc hl
			dec bc
			jp __PRINT_STR_LOOP

__PRINT_STR_END:
	        pop hl
	        ld a, d ; Recovers A flag
	        or a   ; If not 0 this is a temporary string. Free it
	        ret z
	        jp __MEM_FREE ; Frees str from heap and return from there

__PRINT_STR:
	        ; Fastcall Entry
	        ; It ONLY prints strings
	        ; HL = String start
	        ; BC = String length (Number of chars)
	        push hl ; Push str address for later
	        ld d, a ; Saves a FLAG
	        jp __PRINT_STR_LOOP

			ENDP

#line 876 "VecttyRenderer.zxbas"
#line 1 "pstoref.asm"

	; Stores FP number in A ED CB at location HL+IX
	; HL = Offset
	; IX = Stack Frame
	; A ED CB = FP Number

#line 1 "storef.asm"

__PISTOREF:	; Indect Stores a float (A, E, D, C, B) at location stored in memory, pointed by (IX + HL)
			push de
			ex de, hl	; DE <- HL
			push ix
			pop hl		; HL <- IX
			add hl, de  ; HL <- IX + HL
			pop de

__ISTOREF:  ; Load address at hl, and stores A,E,D,C,B registers at that address. Modifies A' register
	        ex af, af'
			ld a, (hl)
			inc hl
			ld h, (hl)
			ld l, a     ; HL = (HL)
	        ex af, af'

__STOREF:	; Stores the given FP number in A EDCB at address HL
			ld (hl), a
			inc hl
			ld (hl), e
			inc hl
			ld (hl), d
			inc hl
			ld (hl), c
			inc hl
			ld (hl), b
			ret

#line 7 "pstoref.asm"

	; Stored a float number in A ED CB into the address pointed by IX + HL
__PSTOREF:
		push de
	    ex de, hl  ; DE <- HL
	    push ix
		pop hl	   ; HL <- IX
	    add hl, de ; HL <- IX + DE
		pop de
	    jp __STOREF

#line 877 "VecttyRenderer.zxbas"
#line 1 "u32tofreg.asm"

#line 1 "neg32.asm"

__ABS32:
		bit 7, d
		ret z

__NEG32: ; Negates DEHL (Two's complement)
		ld a, l
		cpl
		ld l, a

		ld a, h
		cpl
		ld h, a

		ld a, e
		cpl
		ld e, a

		ld a, d
		cpl
		ld d, a

		inc l
		ret nz

		inc h
		ret nz

		inc de
		ret

#line 2 "u32tofreg.asm"
__I8TOFREG:
		ld l, a
		rlca
		sbc a, a	; A = SGN(A)
		ld h, a
		ld e, a
		ld d, a

__I32TOFREG:	; Converts a 32bit signed integer (stored in DEHL)
					; to a Floating Point Number returned in (A ED CB)

		ld a, d
		or a		; Test sign

		jp p, __U32TOFREG	; It was positive, proceed as 32bit unsigned

		call __NEG32		; Convert it to positive
		call __U32TOFREG	; Convert it to Floating point

		set 7, e			; Put the sign bit (negative) in the 31bit of mantissa
		ret

__U8TOFREG:
					; Converts an unsigned 8 bit (A) to Floating point
		ld l, a
		ld h, 0
		ld e, h
		ld d, h

__U32TOFREG:	; Converts an unsigned 32 bit integer (DEHL)
					; to a Floating point number returned in A ED CB

	    PROC

	    LOCAL __U32TOFREG_END

		ld a, d
		or e
		or h
		or l
	    ld b, d
		ld c, e		; Returns 00 0000 0000 if ZERO
		ret z

		push de
		push hl

		exx
		pop de  ; Loads integer into B'C' D'E'
		pop bc
		exx

		ld l, 128	; Exponent
		ld bc, 0	; DEBC = 0
		ld d, b
		ld e, c

__U32TOFREG_LOOP: ; Also an entry point for __F16TOFREG
		exx
		ld a, d 	; B'C'D'E' == 0 ?
		or e
		or b
		or c
		jp z, __U32TOFREG_END	; We are done

		srl b ; Shift B'C' D'E' >> 1, output bit stays in Carry
		rr c
		rr d
		rr e
		exx

		rr e ; Shift EDCB >> 1, inserting the carry on the left
		rr d
		rr c
		rr b

		inc l	; Increment exponent
		jp __U32TOFREG_LOOP


__U32TOFREG_END:
		exx
	    ld a, l     ; Puts the exponent in a
		res 7, e	; Sets the sign bit to 0 (positive)

		ret
	    ENDP

#line 878 "VecttyRenderer.zxbas"

ZXBASIC_USER_DATA:
_pattern:
	DEFW __LABEL35
_pattern.__DATA__.__PTR__:
	DEFW _pattern.__DATA__
_pattern.__DATA__:
	DEFB 0AAh
	DEFB 55h
	DEFB 0AAh
	DEFB 55h
	DEFB 0AAh
	DEFB 55h
	DEFB 0AAh
	DEFB 55h
__LABEL35:
	DEFW 0000h
	DEFB 01h
__LABEL33:
	DEFB 00h
	DEFB 58h
ZXBASIC_MEM_HEAP:
	; Defines DATA END
ZXBASIC_USER_DATA_END EQU ZXBASIC_MEM_HEAP + ZXBASIC_HEAP_SIZE
	; Defines USER DATA Length in bytes
ZXBASIC_USER_DATA_LEN EQU ZXBASIC_USER_DATA_END - ZXBASIC_USER_DATA
	END
